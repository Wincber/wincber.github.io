<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java List小结]]></title>
      <url>http://wincber.com/2017/03/01/java-%E9%9B%86%E5%90%88%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>继续昨天的，集合知识小结。（简单的阅读了源码和网上的一些解读）</p>
<h2 id="Colletion"><a href="#Colletion" class="headerlink" title="Colletion"></a>Colletion</h2><p>和Map并肩构成集合类的最根本的接口，继承自Iterable接口，所有集合都可用迭代器迭代来遍历集合<br><a id="more"></a><br>API主要有：</p>
<pre><code>int size();         集合大小
boolean isEmpty();    是否为空集
boolean contains(Object o);  是否包含o对象
Interator&lt;E&gt; iterator();   返回该集合的迭代器
Object[]  toArray();     集合转数组（无类型）
&lt;T&gt; T[] toArray(T[] a);   集合转数组（建议使用这种方法，且传入数组的类型和大小要和集合一样）
boolean add(E e);   添加元素
boolean remove(Object o)；  删除对象o
boolean containsAll(Collection&lt;?&gt; c);  是否包含另一个集合c
boolean addAll(Collection&lt;? extends E&gt; c);  添加另一个集合
boolean remove All(Collection&lt;?&gt; c); 删除一个集合
default boolean removeIf(predicate&lt;? super E&gt;); filter);  删除满足filter的元素
boolean retainAll(Collection&lt;?&gt; c); 保留集合c的元素，删除其他元素
void clear();  清空集合
</code></pre><h3 id="AbstractCollection-是实现Collection的集合类。实现了Collection除了iterator-和size-抽象方法-以外的其他方法。"><a href="#AbstractCollection-是实现Collection的集合类。实现了Collection除了iterator-和size-抽象方法-以外的其他方法。" class="headerlink" title="AbstractCollection 是实现Collection的集合类。实现了Collection除了iterator()和size()(抽象方法)以外的其他方法。"></a>AbstractCollection 是实现Collection的集合类。实现了Collection除了iterator()和size()(抽象方法)以外的其他方法。</h3><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 继承自 Colletion接口，每个元素都有个索引号，是有序的队列，而且它的元素是可以重复的，除了继承Collection的方法外，还有自己的API接口</p>
<pre><code>boolean add(E e);   添加元素到队尾
boolean remove(Object o)   删除第一次出现的o对象
default void sort(Comparator&lt;? super E&gt; c);    排序（通过Array.sort(c)）  提供比较器用Array.sort来排序
*E get(int index);   获取具体某个索引的元素
*E set(int index,E element)  设置具体某个索引对应的元素为 element
*E add(int index,E element)  在具体索引处插入元素
*E remove(int index) 删除索引为index的元素
*int indexOf(Object o) 查询元素o第一次出现的索引
*int lastIndexOf(Object o) 查询元素o最后一次出现的索引
ListIterator&lt;E&gt; listIterator()  返回有个队列的迭代器
ListIterator&lt;E&gt; listIterator(int index) 返回从index开始的迭代器
*List&lt;E&gt; subList(int fromeIndex,int toIndex) 返回指定的一段子队列
</code></pre><h3 id="AbstractList-继承自AbstractCollection-，实现List接口，除get-和-size-两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类"><a href="#AbstractList-继承自AbstractCollection-，实现List接口，除get-和-size-两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类" class="headerlink" title="AbstractList 继承自AbstractCollection ，实现List接口，除get() 和 size() 两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类"></a>AbstractList 继承自AbstractCollection ，实现List接口，除get() 和 size() 两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类</h3><h4 id="ArrayList-，LinkedList，vector都是继承自AbstractList"><a href="#ArrayList-，LinkedList，vector都是继承自AbstractList" class="headerlink" title="ArrayList ，LinkedList，vector都是继承自AbstractList"></a>ArrayList ，LinkedList，vector都是继承自AbstractList</h4><p>三者区别在于<br>LinkedList：</p>
<pre><code>直接继承的是AbstractSequentialList,且实现了Queue接口。
实际上是一个双向链表，所以它的很多操作都是链表操作，建立链表主要的方法都是私有方法，用于内部链表的建立，比如
定义私有节点类Node&lt;E&gt;
private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
(private)方法
    linkFirst(E e)     链接e作为第一个元素
    unlinkFirst(Node&lt;e&gt; f)  删除非空的第一个节点f
    unlinkLast(Node&lt;e&gt; l)   删除非空的最后一个节点l
    writeObject(java.io.ObjectOutputStream s)  保存链表当前状态到stream中（用于序列化）
    readObject(java.io.ObjectInputStream s)     对应的反序列化
    isElementIndex(int index)   索引index处是否存在元素
    isPositionIndex(int index)  index是否有效
    ...
    （其链表实现与操作的实现与c语言中链表的操作基本相同）

(friendly)方法
    linkLast(E e)   连接e作为队后一个元素
    linkBefore(E e,Node&lt;e&gt; succ)    在节点succ前插入元素e
    unlink(Node&lt;E&gt; x)   删除节点x
其余基本为LinkedList的API,也体现了双向链表的特点（也包含了队列的特点）

    E getFirst()    返回第一个元素
    E getLast()     返回最后一个元素
    E removeFirst() 删除第一个元素
    E removeLast()  删除最后一个元素
    void addFirst(E e)  队头插入元素
    void addLast(E e)   添加元素至队尾
    List所包含的方法都有实现，包括根据索引值来插入删除等。
指的一提的是，LinkedList是没有容量限制的，源码中队size,first(头节点),last(尾节点)都是transient类型的，即暂时性的，他的容量是随操作变化的。此外既然是链表，那么顺序遍历比随机遍历要快，此外他也是线程不安全的，非同步的。
</code></pre><p>ArrayList:</p>
<pre><code>ArrayList是指是一个动态数组，默认容量为10，存储时也是按数组形式存储，当容量不足时，每次增加一半。同样是非同步的。要素是elementData(transient)和size,建议是每次创建时指定好大小。由于是数组形式，遍历时随机访问效率是最高的。
</code></pre><p>Vector</p>
<pre><code>Vector是矢量队列，其特点是可以设置容量的增长指数即capacityIncrement，默认情况下容量不足时是增加一倍。
它的内部实现了许多关于容量的方法以更好的完成对于容量的控制。比如
    ensureCapacityHelper(int minCapacity)   指定最小容量
    grow(int minCapacity)  minCapacity的基础上扩充
    hugeCapacity(int minCapacity)   返回一个大容量
此外，正常情况下分配给array的最大size是Integer.MAX_VALUE - 8 。
注意这里的size和capacity是两个东西，size是元素的数量，capacity是vector的容量。
vector是线程安全的，切随机访问效率最高。
</code></pre><p>Stack</p>
<pre><code>栈是直接继承自Vector的，规律是“后进先出”，也是有特有的的几个方法
push()  压栈
pop()   出栈
peek()  查看栈顶元素
</code></pre><p>##总结<br>做了大概的总结也简单的阅读了源码，其实是有一些关于迭代器的方法没有提到，以后也会再补回来的，明天是Map的相关总结，继续加油！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2.28 Android IPC前两节收获]]></title>
      <url>http://wincber.com/2017/03/01/2-28-Android-IPC/</url>
      <content type="html"><![CDATA[<p>买了《Android开发艺术探索》，看了IPC这一章节的前两个小节，序列化机制和Binder，即进程间通信这一节，谈谈收获<br><a id="more"></a><br>进程间通信在Android开发中好像不是很常说（至少以我的目前少得可怜的经验中除了特意测试进程的demo外没有用过进程间通信）</p>
<h2 id="第一小节-IPC介绍"><a href="#第一小节-IPC介绍" class="headerlink" title="第一小节 IPC介绍"></a>第一小节 IPC介绍</h2><p>第一小节主要介绍了Android IPC机制的概念，主要提出了Andorid上的进程间通信和其他平台上的进程间通信，提到各个平台的特有的进程间通信方式比如Windows的管道，邮槽，Linux上的命名管道，信号量，共享内存等等<br>而Android上特有的就是Binder，此外还有socket（socket在各个平台都可以吧），而用到进程间通信的场景主要1，应用体积大需要开启多进程来获取多块内,2，特殊模块需要单独运行在单个进程中，3，向其他应用获取数据（用ContentProvider也是进程间通信）</p>
<h2 id="第二小节-多进程模式"><a href="#第二小节-多进程模式" class="headerlink" title="第二小节 多进程模式"></a>第二小节 多进程模式</h2><p>第一小节通过android:process的设置的demo介绍了开启新进程的方式<br>第二小节通过创建一个类，通过在不同进程中修改该类中的一个静态变量值而得出的多进程数据不能同步共享因为每个进程中该类是单独的一个副本，修改类中的静态值不会影响其他进程<br>所以多进程可能造成的问题：</p>
<pre><code>1.静态成员和单例模式完全失效
2.线程同步机制完全失效
3.SharedPreferences的可靠性下降（底层通过读/写 XML文件实现，并发读写会出问题）
4.Application会多次创建（一个进程一个应用）
</code></pre><h2 id="第三小节-序列化机制"><a href="#第三小节-序列化机制" class="headerlink" title="第三小节 序列化机制"></a>第三小节 序列化机制</h2><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>是java的序列化，serialVersionUID就是序列化标记，用于辅助进行序列化和反序列化.通过FileOutputStream，FileInputStream进行读写（这里是读写到文件中）来实现简单的序列化</p>
<h3 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h3><p>是android特有的序列化实现Serializable接口后，一个类的对象就能实现序列化可以通过Intent和Binder传递<br>主要实现功能有 </p>
<pre><code>1.序列化  writeToParcel(Parcle out,int flags) 通过Parcel的write方法完成
2.反序列化 CREATOR完成  通过Parcle的read方法完成
3.内容描述 describeContent() 方法完成 （几乎所有情况下都返回0）
</code></pre><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>这节挺难。首先介绍了Binder的概念，是实现了IBinder接口的一个类，是android特有的一个跨进程通信方式。<br>Binder主要用在Service中，包括AIDL和Messenger(底层是AIDL)<br>接着通过生成一个AIDL示例的Demo介绍了系统生成的Binder内部以及如何实现，这一部分比较繁杂，系统生成或者自己写的Binder中重要部分有</p>
<pre><code>1.DESCRIPTOR  Binder的唯一标识（一般是当前类名（包含包名））
2.asInterface(android.os.IBinder obj)   用于将服务端的Binder对象转换成客户端所需的AIDL接口类型对象，可能返回对象本身，可能返回Stub.proxy对象
3.asBinder() 返回当前Binder对象
4.onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags) 运行在Binder线程池中，通过code识别请求方法，data取出数据，reply写入返回值
5.Proxy#getBookList 运行在客户端，通过Parcel对象_data,_reply进行输入输出然后线程挂起，服务端调用ontransact
6.Proxy#addBook 同理
</code></pre><p>暂时到这</p>
<p>总结：IPC机制尤其是Binder虽然我没用过，但是是很有必要了解并明白原理的，明天接着看写！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2月28日：String，StringBuffer，StringBuilder和集合分类]]></title>
      <url>http://wincber.com/2017/02/28/2.28/</url>
      <content type="html"><![CDATA[<p>2月28日的收获：对String，StringBuffer，StringBuilder进行了小研究，简单地查看了源码，也看了网上的讲解三者的区别和优缺点和使用方法对java中的集合部分有了一定的了解。（通过简单的查看源码以及网上博客分析），还有<a id="more"></a> 给博客站点装了个网易云音乐的外链播放器，还不错哦。还有这两天买了两本书《Android开发艺术探索》，《算法导论》，android要了解深层知识，算法也要刷！</p>
<p>废话：刚开学这两天事特别多，压力也很多，事多是身份证丢了要异地补办麻烦的很，还有报了驾校，接下来的日子也要挤出时间来练车，还好这学期课不是很多（暂时），压力大是因为打算找个实习，刚好最近各大公司都开始了内推，心里很纠结，一方面觉得自己实力不够进大公司（甚至小公司自己心里也没有底），另一方面又想试试，唉，但是不管怎么说接下<br>的日子肯定是要加倍努力。<br>正文：<br>想着要实习，是要看一些面试的题目或者老生常谈的问题，刚好这学期课表里也有java，自己也要巩固一下java。所以就来到了String，StringBuffer，StringBuilder三者，以及集合的分类和使用。</p>
<h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><p>网上分析的文章有很多，但想着自己写一遍更加深了解。。。<br>首先它们都是通过 //char[] 来存储字符串的字符，其中String中的 //char[] 是final型的 所以String是不可变的，而StringBuffer和StringBuilder都是继承自AbstractStringBuilder，其字符串是可变的。<br>所以有常说的String不能修改，而要进行字符串的修改的话使用StringBuffer和StringBuilder，而StringBuffer和StringBuilder的区别在于线程安全区别，看源码可以知道StringBuffer和StringBuilder虽然基类都是AbstractStringBuilder且内部方法实现基本相同，但是区别在于，StringBuffer是线程安全的，其与StringBuilder的方法区别是他的方法都是sychronized的即线程同步的，所以在多线程中使用StringBuffer更加安全，而单线程中的话使用StringBuilder会更加高效。</p>
<h2 id="集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类"><a href="#集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类" class="headerlink" title="集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类"></a>集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类</h2><pre><code>List（有序可重复）:ArrayList,LinkedList,Vector,Stack.
Set（不可重复）：HashSet
Map:HashMap HashTable，TreeMap，WeakHashMap
工具类：Arrays，Collections
</code></pre><p>其继承与实现依赖关系可见下图：<br><img src="http://oczm2hjoz.bkt.clouddn.com/Image/jpg/Collection.jpg" width="600" height="500" alt="关系图" align="center"><br>关系很明然对吧，Map这边的还没有看完，所以明天写集合部分的所有总结吧</p>
<p>总结：还是要看一些深层次的东西啊！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android服务器端与客户端Socket通信Demo]]></title>
      <url>http://wincber.com/2016/12/04/android%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AFSocket%E9%80%9A%E4%BF%A1Demo/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  最近计网看到TCP/IP协议，和socket通信，看android的网络编程书上刚开始讲TCP/IP协议，并且讲socket通信，就决定接触一下socket编程，这个涉及到服务器端和客户端两个方面，但是原理是一样的。<br><a id="more"></a></p>
<h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a>Socket 通信</h2><p>  至于TCP/IP协议就不详说了，大家也学过，网上也有很多资料，简单的说，TCP是面向连接的，所以这里用到Socket编程使用socket建立服务器与客户端间的连接。</p>
<p>这个小Demo里做了服务器端和客户端，服务器端是在pc，用SocketServer来搭建，客户端在android上，也是用java的socket来建立。</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>  开始时练习的不是在android上，是java上socket通信，简单的一对一的话不用开启线程，要使多个客户端连入的话就需要每次接3受到一个socket连接就开启一个线程来处理这个socket的通信，要想服务器也向客户端发送消息的话就要再开启发送服务器自定义的消息<br>不过我这儿就发送你控制台输入的消息了（System.in）。当然这样就不能单独向某个客户端发送自定义消息了，而且为开启多少个客户端介入的子线程，就开启多少个接受System.in的子线程，所以每个客户端都会接收到同样的自定义消息。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>  客户端方面需要开启两个线程，一个线程是用来与服务器进行通信，一个线程用来更新UI（将服务器发来的消息显示在TextView中）。<br>大概就是这样。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.服务器IP地址问题<br>  这个demo中客户端链接的是局域网中主机的ip，手机要与PC在同一个局域网中，至于如何换成连接公网（不在同一局域网时也可以通信）这个问题比较麻烦，设计点到点通信之类的计算机网络知识，虽说这学期学了计算机网络，但是。。唉不说了<br>反正就是连公网的话还需要您自己去查阅资料解决，我也回去研究研究，不过这里就不解决了<br>2.发送信息紊乱问题<br>（1）多线程的读写：在刚开始时练习时，多个客户端连入，与服务器互发消息会出现乱掉，问题主要出在服务器端，用于读取接入客户端而创建的套接字的socket的BufferedReader以及勇于写入的BufferedWriter都需要定义为局部变量，因为多线程中的socket不同，读取和写入每个都要单独操作，不然就会出现这个线程中读出的显示在另一个线程中发给服务器的InputStream。<br>（2）服务器端接受System.in的消息发送给所有客户端，需要开启同样数量的子线程，否则会出现有些客户端接受不到服务器发送的自定义消息</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>dash<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class ClientThread implements Runnable &#123;</div><div class="line">Handler mHandler;  // 服务器通信 的handler</div><div class="line">public Handler mRevHandler; // 与UI线程通信的handler</div><div class="line">BufferedReader reader;</div><div class="line">BufferedWriter writer;</div><div class="line">Socket mSocket;</div><div class="line">public ClientThread(Handler handler)&#123;</div><div class="line">    mHandler = handler;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    try&#123;</div><div class="line">        mSocket = new Socket();</div><div class="line">        mSocket.connect(new InetSocketAddress(&quot;192.168.191.1&quot;,23333),60000);</div><div class="line">        Log.d(&quot;socket connecting&quot;,&quot;connecting ...&quot;);</div><div class="line">        reader = new BufferedReader(new InputStreamReader(mSocket.getInputStream()));</div><div class="line">        writer = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                String content = null;</div><div class="line">                try &#123;</div><div class="line">                    while((content = reader.readLine() )!= null )&#123;</div><div class="line">                        Message msg = new Message();</div><div class="line">                        Message msg2 = new Message();</div><div class="line">                        msg.what = 0x66;</div><div class="line">                        msg2.what = 0x22;</div><div class="line">                        msg.obj = content ;</div><div class="line">                        msg2.obj = mSocket.hashCode();</div><div class="line">                        mHandler.sendMessage(msg);</div><div class="line">                        mHandler.sendMessage(msg2);</div><div class="line">                        Log.d(&quot;Received message:&quot; ,content);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        Looper.prepare();</div><div class="line">        mRevHandler = new Handler()&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                if(msg.what == 0x11)&#123;</div><div class="line">                    try &#123;</div><div class="line">                        writer.write(msg.obj.toString()+&quot; from &quot;+ mSocket.hashCode()+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125; catch (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Looper.loop();</div><div class="line">    &#125;catch(IOException e)&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;finally &#123;</div><div class="line">        try &#123;</div><div class="line">            reader.close();</div><div class="line">            writer.close();</div><div class="line">            mSocket.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><p>dash<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">    public class MySocketServer &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MySocketServer socketServer = new MySocketServer();</div><div class="line">        socketServer.startServer();</div><div class="line">    &#125;</div><div class="line">    public void startServer() &#123;</div><div class="line">        ServerSocket serverSocket = null;</div><div class="line">        Socket socket = null;</div><div class="line">        try &#123;</div><div class="line">            String ip;</div><div class="line">            InetAddress adr = InetAddress.getLocalHost();</div><div class="line">            ip = adr.getHostAddress();</div><div class="line">            System.out.println(ip);</div><div class="line">            serverSocket = new ServerSocket(23333);</div><div class="line">            System.out.println(&quot;server start&gt;&gt;&quot;);</div><div class="line">            while(true)&#123;</div><div class="line">                socket = serverSocket.accept();</div><div class="line">                setServerInput(socket);</div><div class="line">                manageConnection(socket);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            try &#123;</div><div class="line">                serverSocket.close();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void setServerInput(final Socket socket)&#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            BufferedReader input = null;</div><div class="line">            BufferedWriter writer = null;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    input = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">                    writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">                    String content;</div><div class="line">                    while((content = input.readLine())!= null)&#123;</div><div class="line">                        writer.write(content+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;finally &#123;</div><div class="line">                    try &#123;</div><div class="line">                        input.close();</div><div class="line">                        writer.close();</div><div class="line">                    &#125; catch (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    public void manageConnection(final Socket socket) &#123;</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            BufferedReader reader = null;</div><div class="line">            BufferedWriter writer = null;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;Socket &quot; + socket.hashCode() + &quot; has connected&quot;);</div><div class="line">                    reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</div><div class="line">                    writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">                    String receivedMsg;</div><div class="line">                    while ((receivedMsg = reader.readLine()) != null) &#123;</div><div class="line">                        System.out.println(receivedMsg);</div><div class="line">                        writer.write(&quot;server received : &quot; + receivedMsg+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125;</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;finally&#123;</div><div class="line">                    try &#123;</div><div class="line">                        reader.close();</div><div class="line">                        writer.close();</div><div class="line">                    &#125;catch (Exception e )&#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，这是个简单的socket通信，也是最基本的服务器客户端通信方式，从简单的开始，慢慢进步！</p>
<p>gituhb：<a href="https://github.com/wincber/SocketTalkClientDemo" target="_blank" rel="external">https://github.com/wincber/SocketTalkClientDemo</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试题知识点（一）]]></title>
      <url>http://wincber.com/2016/10/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到群里有人发面试题我就试着看了看，发现有很多自己不明白的，所以写这个，一方面相当于自己的笔记，也能更好的记住，理解，另一方面也为其他人提供一些知识点参考吧。<br><a id="more"></a></p>
<h3 id="1-listView-优化问题"><a href="#1-listView-优化问题" class="headerlink" title="1. listView 优化问题"></a>1. listView 优化问题</h3><p>感觉这是个老生常谈的问题了。直接说结果<br>1，使用convertView缓存，即在很多地方看到的写适配器的<em>getView</em>方法中用到的，当converView为null时创建新的布局View，当不为空时直接使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View getView（int position，View convertView，View parent） &#123;</div><div class="line">    <span class="keyword">if</span>(convertView == null) &#123;</div><div class="line">        //convertView = your layout View</div><div class="line">    &#125;</div><div class="line">    //操作你的控件,convertView作为layout View</div><div class="line">    </div><div class="line">    <span class="built_in">return</span> convertView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2，使用convertView+ViewHolder<br>就像RecycleView中的ViewHolder，将item中的所要操作的控件写到里面，减少了findViewById<br>则改进部分：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ViewHolder mHolder;</div><div class="line"><span class="keyword">if</span>(convertView == null) &#123;</div><div class="line">    convertView = LayoutInflater.from(context).inflate(...);</div><div class="line">    mHolder = new ViewHolder(); </div><div class="line">    mHolder.textView = (TextView)findViewById(R.id.text);</div><div class="line">    mHolder.imageView = (ImageView)findViewById(R.id.image);</div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    mHolder = (ViewHolder)convertView;</div><div class="line">&#125;</div><div class="line">......</div><div class="line"></div><div class="line">还有一些终极优化技巧就不细说了，可以看这个[http://blog.csdn.net/sweetvvck/article/details/12753851]</div></pre></td></tr></table></figure></p>
<h3 id="2，Activity的启动方式有几种，有什么特点？"><a href="#2，Activity的启动方式有几种，有什么特点？" class="headerlink" title="2，Activity的启动方式有几种，有什么特点？"></a>2，Activity的启动方式有几种，有什么特点？</h3><p>这个问题看了Android开发艺术探索的肯定有了解，就直接说<br>·standard 即标准模式，每次要开启同一个activity A时都会新创建一个A的实例<br>·singleTop 即栈顶复用模式 若要创建的activity已在栈顶，则不创建新的实例，只调用onNewIntent，否则创建新的实例<br>·singleTask 即栈内复用模式 ，要创建的栈若在它所需的任务栈中则不创建新的实例但会clearTop，否则创建新的实例，<br>·singleInstance 单实例模式 该activity单独在一个独有的栈内</p>
<p>我看到的都是问singleTask启动方式，A启动B，B启动C,C再启动A，那么只有A在栈顶了。</p>
<h3 id="3，Hanlder-Looper-MessageQueue-Message-他们的关系"><a href="#3，Hanlder-Looper-MessageQueue-Message-他们的关系" class="headerlink" title="3，Hanlder Looper MessageQueue Message 他们的关系"></a>3，Hanlder Looper MessageQueue Message 他们的关系</h3><p>在看第一行代码时就有说这个的章节，主要是讲异步消息处理机制那块，Android的异步消息处理主要就是由这四个部分组成<br>·Message 线程之间传递数据的载体<br>·handler 主要用来发送和处理消息 sendMessage() handleMessage()<br>·MessageQueue  消息队列 存放Handler发送的消息，等待处理，每个线程中只有一个<br>·Looper 线程调用loop函数进入到无限循环，用于取出MessageQueue的消息，传递到handleMessage()，每个线程只有一个</p>
<h3 id="4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？"><a href="#4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？" class="headerlink" title="4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？"></a>4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？</h3><p>原理还是基于异步消息处理机制<br>AsyncTask是抽象类，需要继承使用，并重写onPreExecute(),doInBackground(params..),onProgressUpdate(progress..),onPostExecute();<br>与Handler关系，AsyncTask实际时Thread+Handler的封装，可以做异步工作同时更新UI，AsyncTask会更加耗费资源<br>api10之前线程池的线程限制5，API10后可自己定制为无限制</p>
<p>先写这四个问题，这里都是直接给出了答案，具体原理以及实现还是最好能去理解记住，有漏错的请提出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拍照裁剪]]></title>
      <url>http://wincber.com/2016/10/16/%E6%8B%8D%E7%85%A7%E8%A3%81%E5%89%AA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本现在什么app都是有个人信息这一栏，有你的头像，有你的其他信息什么的，基本上选择头像的逻辑都是点击头像选择1，拍照 2，从图库中选取<br>所以拍照，照片裁剪基本上是必不可少的，也是在把第一行代码实践一遍的时候发现的问题，并尝试了解决。<br><a id="more"></a></p>
<h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><p>要想知道在你开发的时候最合适的姿势还是要去官网看，也是因为书中的代码有些已经被弃用。<br>先是拍照，第一行代码中的拍照intent是 调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">Intent intent = new Intent(“com.android.media.action.IMAGE_CAPTURE”);</div><div class="line">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE_SECURE);</div></pre></td></tr></table></figure></p>
<p>上述三种调用都可以，需要注意的是<strong>com.android开头的是系统内部应用间的action,在Intent构建中加引号</strong></p>
<p>当然，完整的拍照需要不仅仅是一个intent，还需要用来存储照片的文件，以及用来表示照片的uri。</p>
<p>在这里构建一个方法用来创建你拍照/裁剪后 的图片文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pubilc File createImageFile() throw IOException &#123;</div><div class="line">    String dateFormat = new SimpleDateFormat(<span class="string">"yyyyMMdd_HHmmss"</span>).format(new Date());</div><div class="line">    String imageName = <span class="string">"IMG_"</span> +dateFormat+ <span class="string">"_"</span>;</div><div class="line">    File image = File.createTempFile(</div><div class="line">        imageName,</div><div class="line">        <span class="string">".jpg"</span>,</div><div class="line">        getExternalFileDir(Environment.DIRECTORY_PICTURES);</div><div class="line">    )</div><div class="line">    <span class="built_in">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里设置的存储目录是该应用目录中的Pictures文件夹中</p>
<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>重点在裁剪这里，android是有自带裁剪图片的，但是不同的手机厂商上表现是不同的，所以可以调用系统默认的，但是可能存在一些问题，<br>一些第三方rom会替代默认应用，之前有提过如果你是使用的是com.android.camera.action.IMAGE_CAPTURE的话，<br>因为这个action是系统内部应用间的，所以当第三方应用代替了默认应用，并没有此action，你的应用就会crash，所以可以考虑使用第三方的<br>图片裁剪库。<br>在这里使用的是 <a href="https://github.com/lvillani/android-cropimage" target="_blank" rel="external">https://github.com/lvillani/android-cropimage</a> 这个第三方库，使用方法也很简单，直接看它的Sample就可以<br>需要注意的一点是，因为他提供的知识从图库中选取一张照片来裁剪，当你想在拍照之后直接裁剪拍好的照片的话，<br>就要在你的onActivityResult中添加你的拍照Intent的应答，像这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(requestCode == TAKE_PHOTO &amp;&amp; resultCode == RESULT_OK) &#123;</div><div class="line">    imagUri = data.getData();</div><div class="line">    CropImageIntentBuilder cropIntent = new CropImageIntentBuilder(200,200,imageUri);</div><div class="line">    cropIntent.setSourceImage(imageUri);</div><div class="line">    startActivityForResult(cropIntent.getInten(),CROP_PHOTO);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="展示图片"><a href="#展示图片" class="headerlink" title="展示图片"></a>展示图片</h2><p>这里只用在你的ImageView中展示出来就好了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(requestCode == CROP_PHOTO &amp;&amp; resultCode == RESULT_OK) &#123;</div><div class="line">    try&#123;</div><div class="line">        iv_photo.setImageBitmap(BitmapFactory.decodeStream(getContentResolver.openInputStream(imageUri)));</div><div class="line">    &#125;catch(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>这是系统裁剪和使用这个库裁剪的对比<br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgthird_crop_1.jpg" width="300" height="500" alt="third_crop_1" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgthird_crop_2.jpg" width="300" height="500" alt="third_crop_2" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgsystem_crop_1.jpg" width="300" height="500" alt="system_crop_1" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgsystem_crop_2.jpg" width="300" height="500" alt="system_crop_2" align="center"></p>
<p>所以可以看出来要真的比较的话还是系统裁剪好的多（这里测试使用的是魅族手机），可以调节裁剪框的大小，比例<br>而这里用的第三方只能等比例的调节大小，且裁剪框是一个正方形，无法截取全部，当然如果你用来做头像也是当然可以的了<br>另外一点，第三方的ui有点不好看<br>最后一点，第三方裁剪后会按照压缩成代码中的图片尺寸，而系统的话就是裁多大就是多大</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此可见，这个第三方还不够完美，你可以去找找其他好的库，但是如果用来做头像的话这个裁剪是没问题的</p>
<p>遗留问题:在选取照片时，如果我选中了一个照片，几秒钟内不点确定的话，那张图片会取消它的选择状态，并且暂时无法再选中，除非你先选一下另一个，再选它，为什么呢？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[仿微信界面的Demo]]></title>
      <url>http://wincber.com/2016/09/24/%E4%BB%BF%E5%BE%AE%E4%BF%A1%E7%95%8C%E9%9D%A2%E7%9A%84Demo/</url>
      <content type="html"><![CDATA[<p>先挖坑</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟对ShareSdkd的小小探索]]></title>
      <url>http://wincber.com/2016/09/24/%E8%8F%9C%E9%B8%9F%E5%AF%B9ShareSdkd%E7%9A%84%E5%B0%8F%E5%B0%8F%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>感觉效率太差了，得多点时间看</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView+DialogFragment组合]]></title>
      <url>http://wincber.com/2016/09/17/RecycleView-DialogFragment%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<p>这两天填了坑，总的来说DialogFragment+RecyclerView如果不加动态的数据处理的话只是了解这俩组合还是很简单的，所以我只是用的使DialogFragment+RecycleView再嵌套一个ViewPager。<br>那我先说说大概的结构和步骤。<br><a id="more"></a><br>首先DialogFragment ，想到练DialogFragment是因为android自带的Dialog，AlertDialog等等放在不同版本，风格和样式会不同，用DialogFragment自定义风格好使自己的app风格如一，DialogFragment+RecyclerView可以用到选择账号，选择地区巴拉巴拉，选择什么东西的地方。所以还是在很多地方有用处的</p>
<h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>只说一下在这个练习中的简单使用，若是要看具体详细的使用细节，还是看文档吧<a href="https://developer.android.com/reference/android/app/DialogFragment.html" target="_blank" rel="external">https://developer.android.com/reference/android/app/DialogFragment.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyDialogFragment extends DialogFragment &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View  view = inflater.inflate(R.layout.fragment_list,container);</div><div class="line">        RecyclerView mRecyclerView = (RecyclerView)view.findViewById(R.id.list);</div><div class="line">        mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));</div><div class="line">        mRecyclerView.setAdapter(new MyRecyclerAdapter());</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里只是简单的在onCreateView函数中对嵌套的RecyclerView进行了初始化，设置其适配器。所以在这里其用法还是很简单的</p>
<h2 id="DialogFragment中的MyRecyclerAdapter"><a href="#DialogFragment中的MyRecyclerAdapter" class="headerlink" title="DialogFragment中的MyRecyclerAdapter"></a>DialogFragment中的MyRecyclerAdapter</h2><p>记得使用AndroidStudio的话，其实是有自带的RecyclerFragment，但是我为了简便还是另写RecyclerView的处理。处理本身RecyclerView的处理，两个很重要的点是RecyclerView.ViewHolder和RecyclerView.Adapter<holder><br>ViewHolder也就是你的Recycler里的item 详细介绍在这里 <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html</a><br>而Adapter很熟悉了是你的RecyclerView的适配器。详细介绍在这里 <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html</a><br>我在这个demo里基本没做什么数据处理，所以两者写的很简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyRecyclerHolder extends RecyclerView.ViewHolder&#123;</div><div class="line">    ViewPager mViewPager;</div><div class="line"></div><div class="line">    public MyRecyclerHolder(View itemView) &#123;</div><div class="line">        super(itemView);</div><div class="line">        this.mViewPager = (ViewPager)itemView.findViewById(R.id.pager); //在RecyclerView嵌套的ViewPager</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyRecyclerAdapter extends RecyclerView.Adapter&lt;MyRecyclerHolder&gt; &#123;</div><div class="line">    public int currentItem;</div><div class="line">    @Override</div><div class="line">    public MyRecyclerHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        <span class="built_in">return</span> new MyRecyclerHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_list_item,parent,<span class="literal">false</span>));  //载入RecyclerView的item的布局</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(MyRecyclerHolder holder, int position) &#123;</div><div class="line">        currentItem = holder.getPosition();</div><div class="line">        MyViewPagerAdapter mPagerAdapter = new MyViewPagerAdapter(position);  //将当前item的position传给ViewPager</div><div class="line">        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,400);  //对ViewPager的高度进行设置避免出现不显示内容</div><div class="line">        holder.mViewPager.setLayoutParams(params);</div><div class="line">        holder.mViewPager.setAdapter(mPagerAdapter);    //设置ViewPager的适配器</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">getItemCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></holder></p>
<h2 id="RecyclerView嵌套的ViewPager"><a href="#RecyclerView嵌套的ViewPager" class="headerlink" title="RecyclerView嵌套的ViewPager"></a>RecyclerView嵌套的ViewPager</h2><p>之前有写过ViewPager嵌套ViewPager，所以在这里写的很简单很顺畅，不过在这里没有用FragmentViewPagerAdapter作为ViewPager的适配器，只用的PagerDapter<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MyViewPagerAdapter extends PagerAdapter &#123;</div><div class="line">    int []imagesId = &#123;R.drawable.scenery1,R.drawable.scenery2,R.drawable.scenery3,R.drawable.scenery4,R.drawable.scenery5,R.drawable.scenery6,</div><div class="line">            R.drawable.scenery7,R.drawable.scenery8&#125;;</div><div class="line">    private int mViewPositon;</div><div class="line">    public MyViewPagerAdapter(int position) &#123;</div><div class="line">        mViewPositon = position;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isViewFromObject(View view, Object object) &#123;</div><div class="line">        <span class="built_in">return</span> view== object;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object instantiateItem(ViewGroup container, int position) &#123;</div><div class="line">       View v =  LayoutInflater.from(container.getContext()).inflate(R.layout.pager_item,container,<span class="literal">false</span>);</div><div class="line">        ImageView mImage = (ImageView)v.findViewById(R.id.pager_image);</div><div class="line">        mImage.setImageDrawable(container.getResources().getDrawable(imagesId[2*mViewPositon+position]));</div><div class="line">        container.addView(v); //将内容添加到container（重要）</div><div class="line">        Log.e(<span class="string">"image"</span>,<span class="string">""</span>+position );</div><div class="line">        <span class="built_in">return</span> v;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void destroyItem(ViewGroup container, int position, Object object) &#123;</div><div class="line">         container.removeView((View) object);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>container.addView(view)</strong>这句代码是很重要的，意味着ViewPager显示的内容。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结来说，其实RecyclerView是一个强大的控件，但是在这里只是进行了小小的展示，并没有用到太多的数据处理，所以想要深究RecyclerView的还是要多看看文档或者其他博客。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager 嵌套 ViewPager（ViewPager不能显示，滑动冲突等问题）]]></title>
      <url>http://wincber.com/2016/09/07/ViewPage-%E5%B5%8C%E5%A5%97-ViewPage/</url>
      <content type="html"><![CDATA[<p>这两天才把ViewPager了解学习了一下，也来填一下这个坑（也熟悉一下markdown语法）<br>就不多介绍概念之类的，之说一说我所遇到的坑和给大家的建议</p>
<h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>ViewPager 感觉就不用再详细介绍了，去网上查的话可以查到一大堆介绍什么的。我也是刚接触，不过确实很多地方都用到，比如微信啊，uc浏览器啊，感觉基本上<a id="more"></a>用Tab的地方基本都会用到viewpager设置一些滑动效果之类的。还有最近看到material design 好好看啊，也是许多demo都用到ViewPager</p>
<p>还是放个官方链接吧，最标准的<br><a href="https://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">官方ViewPager文档</a></p>
<h2 id="ViewPager嵌套"><a href="#ViewPager嵌套" class="headerlink" title="ViewPager嵌套"></a>ViewPager嵌套</h2><p>写ViewPager 主要也是为了更加熟练地用ViewPager，但是光是ViewePager是很简单的，看官方的那个demo就知道了，有一点要说，大家用ViewPager的时候一般都是两种写法，一种就是写普通的PagerAdapter，比如一个简单的PagerAdapter</p>
<h3 id="PagerAdapter"><a href="#PagerAdapter" class="headerlink" title="PagerAdapter"></a>PagerAdapter</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class MyPageAdapter extends PagerAdapter &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> list.size();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public boolean isViewFromObject(View arg0, Object arg1) &#123;</div><div class="line">			<span class="built_in">return</span> arg0 == arg1;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public Object instantiateItem(ViewGroup container, int position) &#123;</div><div class="line">			container.addView(list.get(position));</div><div class="line">			<span class="built_in">return</span> list.get(position);</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void destroyItem(ViewGroup container, int position, Object object) &#123;</div><div class="line">			container.removeView(list.get(position));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这四个方法是你必须要重写的</p>
<p><strong><em>instantiateItem(ViewGroup, int)</em></strong>  是你进行页面操作的函数<br><strong><em>destroyItem(ViewGroup, int, Object)</em></strong>  负责销毁你的页面<br><strong><em>getCount()</em></strong> 你的页面数量<br><strong><em>isViewFromObject(View, Object)</em></strong> 判断当前的页面是否展示<br>具体每个方法或者说这个adapter详细的解析可以看看其他大神的文章<br>比如 <a href="http://blog.csdn.net/dmk877/article/details/50060745" target="_blank" rel="external">http://blog.csdn.net/dmk877/article/details/50060745</a> </p>
<p>而另一种则是官方比较推荐的，适配器用FragmentPagerAdapter来写，官方demo就是用的FragmentPagerAdapter写的，所以我在填坑中用的也是这种</p>
<p>怎么写就不单独说了，可以看我写的，或者看官网或者其他人的。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>其实只要你会用一个ViewPager 后，嵌套一个的话也就是在你的外层ViewPager的页面里加一个ViewPager控件，再在你的外层适配器所用到的Fragment中对这个ViewPager进行适配器设置之类的事件<br>大概就像这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyViewPagerFragment extends Fragment &#123;</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_object,container,<span class="literal">false</span>);</div><div class="line">        ImageView images = (ImageView)view.findViewById(R.id.image_iv);</div><div class="line">        images.setImageDrawable(getResources().getDrawable(getArguments().getInt(<span class="string">"pager"</span>)));</div><div class="line">        NestingViewPager nestPager = (NestingViewPager)view.findViewById(R.id.nesting_vp);</div><div class="line">        nestPager.setAdapter(new NestingViewPagerAdapter(getChildFragmentManager()));</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内层ViewPager的适配器和Fragment再单独写<br>那么遇到的问题有哪些？</p>
<h3 id="内层ViewPager不显示"><a href="#内层ViewPager不显示" class="headerlink" title="内层ViewPager不显示"></a>内层ViewPager不显示</h3><p>因为我的外层ViewPager的布局是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span> </div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span> &gt;</div><div class="line">    &lt;ScrollView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span>&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:id=<span class="string">"@+id/image_iv"</span></div><div class="line">        android:src=<span class="string">"@drawable/icon1"</span></div><div class="line">        android:layout_gravity=<span class="string">"center_horizontal"</span>/&gt;</div><div class="line">    &lt;com.example.wincber.viewpagetest.NestingViewPager</div><div class="line">            android:layout_width=<span class="string">"match_parent"</span></div><div class="line">            android:layout_height=<span class="string">"match_parent"</span></div><div class="line">            android:id=<span class="string">"@+id/nesting_vp"</span>&gt;</div><div class="line">    &lt;/com.example.wincber.viewpagetest.NestingViewPager&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;/ScrollView&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>运行后只显示ImageView不显示我的内层ViewPager所以我查阅了很多资料，大概主要有这两点</p>
<h4 id="getChildFragmentManager"><a href="#getChildFragmentManager" class="headerlink" title="getChildFragmentManager()"></a>getChildFragmentManager()</h4><p>内层ViewPager的Adapter（FragmentAdapter）再创建时调用的是<strong><em>getChildFragmentManager()</em></strong><br>当然外层的则调用的是<strong><em>getSupportFragmentManager()</em></strong></p>
<h4 id="ScrollView所嵌套的ViewPager中的Height进行具体的高度设置"><a href="#ScrollView所嵌套的ViewPager中的Height进行具体的高度设置" class="headerlink" title="ScrollView所嵌套的ViewPager中的Height进行具体的高度设置"></a>ScrollView所嵌套的ViewPager中的Height进行具体的高度设置</h4><p>我开始不用ScrollView不能显示完整的View，当然内层的ViewPager也显示不出来，对内层的ViewPager的高度进行设置是最简单直接的方法，缺点就是固定数值的限制<br>当然还有更科学严谨的办法，大家可以看看这篇，作者提供了三种方法<br><a href="http://hellsam.com/2015/01/29/Android%E7%9A%84%E5%9D%91%E4%B9%8BScrollView%E5%B5%8C%E5%A5%97ViewPager/" target="_blank" rel="external">ScrollView里面嵌套ViewPager之后ViewPager中的内容无法显示</a></p>
<p>我遇到的无法显示的问题就是这么解决的啦</p>
<h3 id="滑动问题"><a href="#滑动问题" class="headerlink" title="滑动问题"></a>滑动问题</h3><p>关于滑动问题（内外冲突，内层划置最边上（像第一个页面右划，向最后一个页面左划））我是通过重写<strong><em>onTouchEvent(MotionEvent arg0)</em></strong>来解决（自己写内层ViewPager）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent arg0) &#123;</div><div class="line">      curF.x = arg0.getX();</div><div class="line">      curF.y = arg0.getY();</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(arg0.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">          downF.x = arg0.getX();</div><div class="line">          downF.y = arg0.getY();</div><div class="line">          getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(arg0.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">          curF.x =arg0.getX();</div><div class="line">          curF.y=arg0.getY();</div><div class="line">          <span class="keyword">if</span>(Math.abs(curF.x-downF.x) &gt; Math.abs(curF.y - downF.y)) &#123;</div><div class="line">              <span class="keyword">if</span>(curF.x &gt; downF.x) &#123; //右划</div><div class="line">                  <span class="keyword">if</span> (getCurrentItem() == 0) &#123;//第一个页面，需要父控件拦截</div><div class="line">                      getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;//左划</div><div class="line">                  <span class="keyword">if</span> (getCurrentItem() == getAdapter().getCount() - 1) &#123;//最后一个页面，需要拦截</div><div class="line">                      getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;<span class="keyword">else</span> &#123;//上下划，需要拦截</div><div class="line">              getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> super.onTouchEvent(arg0);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>注释也说的很明白了，你肯定能看明白。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ViewPager已经是被用到很多地方的控件了，掌握它还是蛮重要的，通过对其的练习了解到了很多。<br>文章中一些名词或者概念讲的不对或者不清楚的请提出，水平有限，想研究关于ViewPager更深层的问题还是看文档或者大神的文章吧。</p>
<p>这里是我的demo ： <a href="https://github.com/wincber/ViewPager_inside_ViewPager/tree/master" target="_blank" rel="external">https://github.com/wincber/ViewPager_inside_ViewPager/tree/master</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories test]]></title>
      <url>http://wincber.com/2016/09/05/categories-test/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[hello blog]]></title>
      <url>http://wincber.com/2016/09/03/hello-blog/</url>
      <content type="html"><![CDATA[<p>It’s my first test about Blog,hope that I can get more .</p>
<h2 id="It’s-A-title"><a href="#It’s-A-title" class="headerlink" title="It’s A title"></a>It’s A title</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Blog]]></title>
      <url>http://wincber.com/2016/09/02/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to my Blog !今天起开始好好的在这里写一些自己在学习过程中遇到的一些我所认为的重要的东西<br><a id="more"></a></p>
<h2 id="为什么要开博客"><a href="#为什么要开博客" class="headerlink" title="为什么要开博客"></a>为什么要开博客</h2><h3 id="激励自己"><a href="#激励自己" class="headerlink" title="激励自己"></a>激励自己</h3><p>虽然在csdn之类的也写了一些自己学习过程中遇到的问题，但我感觉这个要能更加正式，督促自己能更好的写东西，这里也尽量写一些实用的东西，向那些小问题就尽量避免<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Come on</div></pre></td></tr></table></figure></p>
<h3 id="赶上潮流"><a href="#赶上潮流" class="headerlink" title="赶上潮流"></a>赶上潮流</h3><p>之前就看过很厉害的学长的博客，而最近群里的一些小伙伴也好像都有这方面的意向，我也就赶个热</p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="装逼"><a href="#装逼" class="headerlink" title="装逼"></a>装逼</h3><p>这是我的网站，想想还有点小激动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">It<span class="string">'s my Website</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java-Set小结]]></title>
      <url>http://wincber.com/2017/03/18/java-Set%E5%B0%8F%E7%BB%93/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[《Spring3.x企业应用及开发实战》学习：Java反射知识(一)]]></title>
      <url>http://wincber.com/2017/03/15/Spring-%E5%AD%A6%E4%B9%A0%EF%BC%9AJava-%E5%8F%8D%E5%B0%84%E7%9F%A5%E8%AF%86-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>学习Spring的Ioc（反转控制）时要先了解一些java的反射的基础知识。今天看了一部分，这里做个总结。<a id="more"></a><br>反射时通过对象获取所属类Class的结构信息，从而课一程序化方式操作Class对象。具体作用还是程序代码和配置文件的分离吧（虽然目前自己还没有体会出来）。<br>主要时测试了应用到了反射的一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class ReflectTest &#123;</div><div class="line">    public static Car initByDefaultConst() throws  Throwable&#123;</div><div class="line">        //类装载器ClassLoader获取Car类对象</div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">        Class clazz = loader.loadClass(&quot;com.wincber.SpringIoc.Car&quot;);</div><div class="line"></div><div class="line">        //获取累的默认构造器对象并通过它实例化对象。</div><div class="line">        Constructor constructor = clazz.getDeclaredConstructor((Class[])null);</div><div class="line">        Car car = (Car) constructor.newInstance();  //newInstance 作用相当于new XX</div><div class="line"></div><div class="line">        //通过反射方法设置属性</div><div class="line"></div><div class="line">        Method setBrand = clazz.getMethod(&quot;setBrand&quot;,String.class);</div><div class="line">        setBrand.invoke(car,&quot;劳斯莱斯&quot;);</div><div class="line">        Method setColor = clazz.getMethod(&quot;setColor&quot;,String.class);</div><div class="line">        setColor.invoke(car,&quot;红色&quot;);</div><div class="line">        Method setMaxSpeed = clazz.getMethod(&quot;setMaxSpeed&quot;,int.class);</div><div class="line">        setMaxSpeed.invoke(car,100);</div><div class="line">        return car;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws Throwable&#123;</div><div class="line">       Car car = initByDefaultConst();</div><div class="line">       car.introduce();</div><div class="line">       ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">       System.out.println(&quot;current loader &quot;+ loader);</div><div class="line">       System.out.println(&quot;parent loader &quot;+ loader.getParent());</div><div class="line">       System.out.println(&quot;grandParent loader &quot;+ loader.getParent().getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有就是类装载器ClassLoader这一节的介绍里的一些知识：<br>类装载器把一个类装入JVM的过程：<br>    1.装载：查找和导入Class文件。<br>    2.链接：执行校验，准备和解析步骤（可选）<br>        a.校验：检查载入Class文件数据的正确性<br>        b.准备: 给类的静态变量分配存储空间<br>        c.解析: 将符号引用转成直接以用<br>    3.初始化: 对类的静态变量，静态代码块执行初始化工作。<br>其次还介绍了三个主要的ClassLoader: 根装载器，ExtClassLoader,AppClassLoader，挨个继承下来的。存在这样的机制也是因为JVM装载时使用“全盘负责委托机制”(总是先委托父装载器寻找目标类)，位的时避免类似于恶意基础类装载到JVM发生的错误。<br>最后放个图，java的内存模型：</p>
<p><a href="http://oczm2hjoz.bkt.clouddn.com/image/jpg/java_reflect.jpg" target="_blank" rel="external">!内存模型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxAndroid 初试]]></title>
      <url>http://wincber.com/2017/03/12/RxAndroid-%E5%88%9D%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>RxJava和RxAndroid 是ReactiveX的java实现版，其实是异步操作框架，是一种观察者模式实现的框架。十分的简洁十分有必要了解学习一下。所以昨天就看了基本的用法并照着写了个demo。掌握？不存在的，知识简单知道怎么用了。<a id="more"></a></p>
<h2 id="观察者模式和RxJava"><a href="#观察者模式和RxJava" class="headerlink" title="观察者模式和RxJava"></a>观察者模式和RxJava</h2><p>光说这里体现的观察者模式Observable被观察者，Observer观察者，观察者对被观察者的时间变化做出反应，就像View和OnClickedListener一样，当有OnClick事件发生在View上时,OnClickedListner执行响应函数。<br>而除了Observer外，还有Subscriber，是它的一个扩展类，使用方法基本相同。<br>而Observer通过subscribe()方法实现订阅，Observable.subscribe(Observer/Subscriber)<br>而新建的Observer对象中要实现三个回调方法onNext(T t),onError(Exception e),onComplete();<br>还有其他的一些操作符（可以看作是它的其他一些方法），都是用来初始化数据，使发送到观察者（订阅者）的数据是我们需要的。<br>有一个要记一下的是这个demo代码里所用到的subscribeOn(Schedules.newThread()) 即消费（Observable的call方法）事件在一个新的线程中。以及observeOn(AndroidSchedules.mainThread()) 订阅事件(subscriber的一系列回调方法)发生在应用的主线程中即UI线程中。<br>一下是初试的代码：</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>最重要的两个东西就是Observables(观察者)和Subscribers(订阅者)，关系就像OnClickedListener和Button的关系，观察者发送事件，订阅者接受并处理事件<br>RxActivity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">import rx.Observable;</div><div class="line">import rx.Subscriber;</div><div class="line">import rx.Subscription;</div><div class="line">import rx.android.schedulers.AndroidSchedulers;</div><div class="line">import rx.schedulers.Schedulers;</div><div class="line"></div><div class="line">public class RxActivity extends BaseActivity&#123;</div><div class="line">    private EditText input;</div><div class="line">    private Button check;</div><div class="line">    private TextView content;</div><div class="line">    private Subscription subscription;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_rx);</div><div class="line">        initView();</div><div class="line">        initEvent();</div><div class="line">    &#125;</div><div class="line">    void initView()&#123;</div><div class="line">        input = findView(R.id.et_input_rx);</div><div class="line">        check = findView(R.id.bt_check_rx);</div><div class="line">        content = findView(R.id.tv_content_rx);</div><div class="line">    &#125;</div><div class="line">    void initEvent()&#123;</div><div class="line">        check.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                observableAsNormal(input.getText().toString().trim());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    //rxjava的具体实现过程</div><div class="line">    private void observableAsNormal(final String city)&#123;</div><div class="line">        subscription = Observable.create(new Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super Weather&gt; subscriber) &#123;</div><div class="line">                if(subscriber.isUnsubscribed()) return;</div><div class="line">                try &#123;</div><div class="line">                    String weatherInfo = WeatherConstant.getWeather(WeatherConstant.getWeatherApiUrl(city));    //获取天气信息XML</div><div class="line">                    Weather weather = WeatherConstant.parseXNLWithPull(weatherInfo);    //pull方式解析天气信息XML</div><div class="line">                    subscriber.onNext(weather);</div><div class="line">                    subscriber.onCompleted();</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    subscriber.onError(e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribeOn(Schedulers.newThread())  //消费事件在新开启的一个线程中。</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())  //观察事件在主线程中（UI线程）</div><div class="line">                .subscribe(new Subscriber&lt;Weather&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void onCompleted() &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Throwable e) &#123;</div><div class="line">                        Toast.makeText(RxActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onNext(Weather weather) &#123;</div><div class="line">                    content.setText(weather.toString());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        if(subscription != null &amp;&amp; !subscription.isUnsubscribed())</div><div class="line">            subscription.unsubscribe();</div><div class="line">        super.onDestroy();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Weather的解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">public class WeatherConstant &#123;</div><div class="line">    private static  String  WEATHER_API_URL=&quot;http://php.weather.sina.com.cn/xml.php?city=%s&amp;password=DJOYnieT8234jlsK&amp;day=0&quot;;</div><div class="line">    private static OkHttpClient client = new OkHttpClient();</div><div class="line">    //获取查询城市的天气api</div><div class="line">    public static String getWeatherApiUrl(String city)&#123;</div><div class="line">        String urlString = null;</div><div class="line">        try &#123;</div><div class="line">             urlString = String.format(WEATHER_API_URL, URLEncoder.encode(city, &quot;GBK&quot;));    // 输入为汉字，GBK编码格式化如API中</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return urlString;</div><div class="line">    &#125;</div><div class="line">    //okhttp发送get请求</div><div class="line">    public static String getWeather(final String url)&#123;</div><div class="line">        final Request request = new Request.Builder().get().url(url).build();</div><div class="line">        StringBuffer buffer = new StringBuffer();</div><div class="line">        try &#123;</div><div class="line">            Response response = client.newCall(request).execute();</div><div class="line">            if(response.isSuccessful())&#123;</div><div class="line">                buffer.append(response.body().string()) ;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return buffer.toString();</div><div class="line">    &#125;</div><div class="line">    //pull方式解析天气XML信息</div><div class="line"></div><div class="line">    public static Weather parseXNLWithPull(String xmlData)&#123;</div><div class="line">        XmlPullParser xmlPullParser = Xml.newPullParser();</div><div class="line">        StringReader reader = new StringReader(xmlData);</div><div class="line">        Weather weather = null;</div><div class="line">        try &#123;</div><div class="line">            xmlPullParser.setInput(reader);</div><div class="line">            int eventType = xmlPullParser.getEventType();</div><div class="line">            while(eventType != XmlPullParser.END_DOCUMENT)&#123;</div><div class="line">                switch (eventType)&#123;</div><div class="line">                    case XmlPullParser.START_DOCUMENT:</div><div class="line">                        weather = new Weather();</div><div class="line">                        break;</div><div class="line">                    case XmlPullParser.START_TAG:&#123;</div><div class="line">                        String nodeName = xmlPullParser.getName();</div><div class="line">                        if(&quot;city&quot; .equals(nodeName))&#123;</div><div class="line">                            weather.setCity(xmlPullParser.nextText());</div><div class="line">                        &#125;else if(&quot;savedate_weather&quot; .equals(nodeName))&#123;</div><div class="line">                            weather.setDate(xmlPullParser.nextText());</div><div class="line">                        &#125; else if(&quot;temperature1&quot;.equals(nodeName)) &#123;</div><div class="line">                            weather.setTemperature( xmlPullParser.nextText());</div><div class="line">                        &#125; else if(&quot;temperature2&quot;.equals(nodeName))&#123;</div><div class="line">                            weather.setTemperature(&quot;--&quot; +  xmlPullParser.nextText());</div><div class="line">                        &#125; else if(&quot;direction1&quot;.equals(nodeName))&#123;</div><div class="line">                            weather.setDirection(xmlPullParser.nextText());</div><div class="line">                        &#125; else if(&quot;power1&quot;.equals(nodeName))&#123;</div><div class="line">                            weather.setPower( xmlPullParser.nextText());</div><div class="line">                        &#125; else if(&quot;status1&quot;.equals(nodeName))&#123;</div><div class="line">                            weather.setStatus( xmlPullParser.nextText());</div><div class="line">                        &#125;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                eventType = xmlPullParser.next();</div><div class="line">            &#125;</div><div class="line">            return weather;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            reader.close();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RxJava&amp;RxAndroid是非常强大的框架，很有必要学会使用，今天只是使用了最初级的create和subscribe，它还有许多操作符，以及lambda写法接下来都要学习一下。</p>
<p>主要是看这两篇文章来认识和练习的：</p>
<p><a href="http://wuxiaolong.me/2016/01/18/rxjava/" target="_blank" rel="external">http://wuxiaolong.me/2016/01/18/rxjava/</a><br><a href="http://blog.csdn.net/job_hesc/article/details/45798307" target="_blank" rel="external">http://blog.csdn.net/job_hesc/article/details/45798307</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[3.7-LeetCode-刷题]]></title>
      <url>http://wincber.com/2017/03/07/3-7-LeetCode-%E5%88%B7%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="ZigZagConversation"><a href="#ZigZagConversation" class="headerlink" title="ZigZagConversation"></a>ZigZagConversation</h2><p><a href="https://leetcode.com/problems/zigzag-conversion/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/zigzag-conversion/?tab=Description</a><br>这个题首先明白什么是ZigZag pattern才能做，它是这样的格式<br>/*n=numRows</p>
<pre><code>Δ=2n-2    1                           2n-1                         4n-3
Δ=        2                     2n-2  2n                    4n-4   4n-2
Δ=        3               2n-3        2n+1              4n-5       .
Δ=        .           .               .               .            .
Δ=        .       n+2                 .           3n               .
Δ=        n-1 n+1                     3n-3    3n-1                 5n-5
Δ=2n-2    n                           3n-2                         5n-4
</code></pre><p>*/<br><a id="more"></a><br>这样就一目了然了，需要循环着从0-(numRows-1),再返回至0，还是比较简单的，直接代码：</p>
<pre><code>public String convert(String s, int numRows) {
    StringBuilder[] sbs = new StringBuilder[numRows];
    for(int i = 0;i &lt; numRows;i++)
        sbs[i] = new StringBuilder();
    int len = s.length();
    int temp = 0;
    if(numRows == 1)
    sbs[0].append(s);
    else
    for(int i = 0,j = 0;i &lt; len;i++){
       if(j == numRows - 1) temp = -1;
       if(j == 0 &amp;&amp; i != 0 ) temp = 1;
       j += temp;
       sbs[j].append(s.charAt(i));
    }
    for(int i = 0;i &lt; numRows;i++){
        sbs[0].append(sbs[i]);
    }
    return sbs[0].toString();
}
</code></pre><p>需要注意的地方是，在0和numRows-1处的转折，这个题也让我测试得到了StringBuilder确实要比StringBuffer，前者61ms，后者67ms。</p>
<h2 id="Keyboard-Row"><a href="#Keyboard-Row" class="headerlink" title="Keyboard Row"></a>Keyboard Row</h2><p><a href="https://leetcode.com/problems/keyboard-row/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/keyboard-row/?tab=Description</a><br>这个题也是简单级别，通过率也是高，有多种方法。<br>第一种是我自己写的，时间是9ms<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public String[] findWords(String[] words) &#123;</div><div class="line">       String s1 = &quot;QWERTYUIOP&quot;;</div><div class="line">       String s2 = &quot;ASDFGHJKL&quot;;</div><div class="line">       String s3 = &quot;ZXCVBNM&quot;;</div><div class="line">       int w1 = 0,w2 = 0,w3 = 0,j = 0;</div><div class="line">       HashMap&lt;Character,Integer&gt; map1 = new HashMap&lt;Character,Integer&gt;();</div><div class="line">       for(int i = 0;i &lt; s1.length();i++)</div><div class="line">           map1.put(s1.charAt(i),i);</div><div class="line">       HashMap&lt;Character,Integer&gt; map2 = new HashMap&lt;Character,Integer&gt;();</div><div class="line">       for(int i = 0;i &lt; s2.length();i++)</div><div class="line">           map2.put(s2.charAt(i),i);</div><div class="line">       HashMap&lt;Character,Integer&gt; map3 = new HashMap&lt;Character,Integer&gt;(); //讲键盘上的字符行放入map中</div><div class="line">       for(int i = 0;i &lt; s3.length();i++)</div><div class="line">           map3.put(s3.charAt(i),i);</div><div class="line">       List&lt;String&gt; list = new ArrayList&lt;String&gt;();    //list来放符合条件的String</div><div class="line">       for(int i = 0;i &lt; words.length;i++)&#123;</div><div class="line">           w1 = 0;w2 = 0;w3 = 0;</div><div class="line">           for(j = 0;j &lt; words[i].length();j++)&#123;</div><div class="line">               if(map1.containsKey(words[i].toUpperCase().charAt(j)))</div><div class="line">                   w1++;</div><div class="line">               else if(map2.containsKey(words[i].toUpperCase().charAt(j)))</div><div class="line">                   w2++;</div><div class="line">               else</div><div class="line">                   w3++;</div><div class="line">           &#125;   //比较它监测到的次数和当前字符串长度来看是不是全都在该字符串内。</div><div class="line">           if(w1 == j || w2 == j || w3 == j) list.add(words[i]);</div><div class="line">       &#125;</div><div class="line">       return (String [])list.toArray(new String[list.size()]);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>注意点在于查找时用大写查找</p>
<p>第二种是solution中的一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public String[] findWords(String[] words) &#123;</div><div class="line">    String[] strs = &#123;&quot;QWERTYUIOP&quot;,&quot;ASDFGHJKL&quot;,&quot;ZXCVBNM&quot;&#125;;</div><div class="line">    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">    for(int i = 0; i&lt;strs.length; i++)&#123;</div><div class="line">        for(char c: strs[i].toCharArray())&#123;</div><div class="line">            map.put(c, i);          //不同之处在于放入键值对时放入的是字符和当前所在行作值。</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</div><div class="line">    for(String w: words)&#123;</div><div class="line">        if(w.equals(&quot;&quot;)) continue;</div><div class="line">        int index = map.get(w.toUpperCase().charAt(0));</div><div class="line">        for(char c: w.toUpperCase().toCharArray())&#123;</div><div class="line">            if(map.get(c)!=index)&#123;      // 比较是不是还在当前行</div><div class="line">                index = -1;  </div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(index!=-1) res.add(w);</div><div class="line">    &#125;</div><div class="line">    return res.toArray(new String[0]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>这种算法的一个巧妙地点就是放入键值对时放进的是字符和当前所在的row，比较时也是取出第一个字符的所在行若遇到不同行则标记并停止，这样节省了继续搜索的时间。
</code></pre><p>第三种是最简单，用正则（但是效率很慢，不过我竟然当时想都没想）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public String[] findWords(String[] words) &#123;</div><div class="line">       return Stream.of(words).filter(s -&gt; s.toLowerCase().matches(&quot;[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*&quot;)).toArray(String[]::new);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>用掉了136ms</p>
<h2 id="Integer-Reverse"><a href="#Integer-Reverse" class="headerlink" title="Integer Reverse"></a>Integer Reverse</h2><p><a href="https://leetcode.com/problems/reverse-integer/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/reverse-integer/?tab=Description</a><br>这道题是很简单的数字反转的算法，但是通过率很低也是因为一个是照顾到Integer的范围2^32-1 —— -2^32，所以若将转换结果刚开始就定义为int时有可能在转换过程中由于达到了边界再运算时会从另一边界处开始，所以开始时要定义成长整型，long，返回结果时判断是否超过边界决定是否返回0，此外正负数模10结果只是符号相反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public int reverse(int x) &#123;</div><div class="line">    long result = 0;</div><div class="line">    while(x != 0)&#123;</div><div class="line">        result = result * 10 + x%10;</div><div class="line">        x /= 10;</div><div class="line">    &#125;</div><div class="line">    return (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE)?0:(int)result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring 开发初试]]></title>
      <url>http://wincber.com/2017/03/07/Spring-%E5%BC%80%E5%8F%91%E5%88%9D%E8%AF%95/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit Android 初试]]></title>
      <url>http://wincber.com/2017/03/07/Retrofit-Android-%E5%88%9D%E8%AF%95/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android MVP 初试]]></title>
      <url>http://wincber.com/2017/03/07/Android-MVP-%E5%88%9D%E8%AF%95/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[java Map 小结]]></title>
      <url>http://wincber.com/2017/03/06/java-Map-%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>List之后当然是Map，学习算法时会经常用到HashMap，HashTable之类的，这都是基于实现Map接口的，包括Set也是基于Map来实现的。Map是存储着键值对的映射接口，源码开头也说明它不能存储重复的键值对，可以被看作为键值对的Collection。<a id="more"></a><br>先看Map</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map作为一个最底层的实现的映射接口，其API</p>
<pre><code>int size();    返回Map的大小
boolean isEmpty()     此Map是否为空
boolean containsKey(Object key)     是否包含键key
boolean containsValue(Object value)     是否包含值value(可能是单个或多个)
V get(Object key)   返回key所对应的值value
V put(K key,V value)    放入键值对key-value（若有，替换旧的键值对）
V remove(Object key)    删除key对应的键值对
void putAll(Map&lt;? extends K,? extends V&gt; m)    将m复制进Map中
void clear()    清空Map
Set&lt;K&gt; keySet()     返回键集的Set集合
Collection&lt;V&gt;  values()     返回值集的Collection集合
Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet()    返回键值对Entry集的Set集合
boolean equals(Object o)    与o是否相等(调用每个entry的equals方法)
int hashCode()  返回该map的hashCode（每个entry的hashCode的总和）
</code></pre><p>Entry<k,v>作为一个存储键值对的实体，其内部的API主要是get/set key/value,equals,hashCode()(key和value的hashcode异或即为entry的hashcode),以及四个静态方法（从JDK1.8出现），分别是</k,v></p>
<pre><code>comparingByKey();       根据key比较
comparingByValue();     根据value比较
comparingByKey(Comparator&lt;? extends K&gt; cmp);    根据key按比较器cmp来比较
comparingByValue(Comparator&lt;? extends V&gt; cmp);  根据value按比较器cmp来比较
</code></pre><p>均返回一个序列化的Comparator。<br>以及一系列的default的方法实现</p>
<h2 id="AbstarcMap"><a href="#AbstarcMap" class="headerlink" title="AbstarcMap"></a>AbstarcMap</h2><p>AbstractMap实现了Map接口，定义了内部变量，keySet,values，以及一个抽象方法entrySet(),大部分操作都是基于它们来的</p>
<pre><code>int size() ; 返回大小（返回的实际是entrySet().size()）
boolean isEmpty();  是否为空（通过判断size()）
boolean containsKey(Object key); boolean contansValue(Object value);V remove(Object key)  是否包含key/value，删除key对应的entry,三个方法的实现都是通过迭代器iterator迭代entrySet.iterator()，遍历每个实体进行查询。 value和key均可以为null
V get(Object k) 返回k对应的value（同样利用entrySet.iterator()迭代器遍历获取）   
V put(K key,V value)    不支持！
以及putAll,clear都是利用entrySet()
Set&lt;K&gt; keySet(); Collectio&lt;V&gt; values(); 将keySet,values进行实例化，分别实例AbstractSet,AbstactCollection
以及其他Map的API
值得一提的是 toString()   用entrySet.iterator()遍历，用的是StringBuilder将字符串扩展，返回的格式是{key1=value1, key2=value2}
protected Object clone()    复制

内部定义的一个SimpleEntry
</code></pre><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 直接继承自AbstractMap,源码中也说了HashMap基本就是HashTable，是个散列表，存储键值对均不是有序的，除了他可以允许存储null的key和null的value，且是不同步的（非线程安全）。<br>其默认初始容量为16，默认加载因子时0.75。（它实际是由数组+链表+红黑树组成）</p>
<p>它的几个静态全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;      默认初试容量为16，自定义时也必须是2的幂</div><div class="line">int MAXNUM_CAPACITY = 1 &lt;&lt; 30   默认最大容量是1 &lt;&lt; 30，也可以自己指定，但必须&lt;= 1 &lt;&lt; 30</div><div class="line">int DEFAULT_LOAD_FACTOR = 0.75f     more加载因子为0.75</div><div class="line">int TREEIFY_THRESHOLD = 8   容器被转化为树的最小情况</div><div class="line">int UNTREEIFY_THRESHOLD = 6     树转化为bins的因子数</div><div class="line">int MIN_TREEIFY_CAPACITY = 64   容器可转化为树状时表的最小容量</div></pre></td></tr></table></figure></p>
<p>静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int hash(Object key)&#123;</div><div class="line">    int h ;</div><div class="line">    return (key == null)?0:(h=key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;    计算key的hashCode并把从高位的hash扩展到低位的hash</div><div class="line"></div><div class="line">hash函数返回的hash值与容量-1的与运算可得到该结点再map（或者说table）中的位置。</div><div class="line"></div><div class="line">Class&lt;?&gt; comparableClassFor(Object x)   返回x的Class 如果他的组成是&quot;class C implenments Comparable&lt;C&gt;&quot; </div><div class="line">int compareComparables(Class&lt;?&gt; kc,Object k,Object x)   返回k与x的比较值如果k是kc类的话</div><div class="line">final int table tableSizeFor(int cap)   根据给定的目标capacity返回一个2的幂的size。（调整capacity）</div></pre></td></tr></table></figure></p>
<p>他有几个重要的成员变量</p>
<pre><code>transident Node&lt;K,V&gt; table;     Node类实际就是Entry,长度总是2的幂,每个Node都是一个单向链表
transident Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet;   entry的Set集合
transident int size;    map的大小
transident int modCount;    改变结构的次数，用来实现fail-fast机制
int threshold;      resize后的size大小(等于容量*加载因子  capacity * load factor)
final float loadFactor;     加载因子
</code></pre><p>静态类</p>
<pre><code>Node&lt;K,V&gt;  最基本的哈希容器节点，大部分entry实体使用的都是这个类（hashCode的实现和LinkedList中一样都是key的hashCode和value的hashCode的异或）
</code></pre><p>四个构造函数</p>
<pre><code>public HashMap();   
public HashMap(int initialCapacity);     初始化容量为initialCapacity，加载因子为默认0.75
public HashMap(int initialCapacity,float loadFactor);   指定初始化容量和加载因子
public HashMap(Map&lt;? extends K,? extends V&gt; m);     创建与m相同键值对的HashMap
</code></pre><p>主要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">final void putMapEntries(Map&lt;? extends K,? extends V&gt;m,boolean evict );    实现Map.putAll 和 Map的构造函数,给这俩函数调用，内部主要是通过一系列的条件判断后，将m的每个entry复制进本map里，条件有容量的判断，treshold的判断</div><div class="line">int size();     返回map的键值对数量</div><div class="line">boolean isEmpty()   size是否为0</div><div class="line">V get(Object key)   返回key所对应的value</div><div class="line">final Node&lt;K,V&gt; getNode(int hash,Object key);   返回hash和key所对应的节点Node       每次都先单独检查第一个，检查key，以及key.hash</div><div class="line">boolean containsKey(Object key)     是否包含key(通过getNode(hash(key),key)的返回值来判断)</div><div class="line">V put(K key,V value);   放入key-value键值对(通过调用putVal(hash(key),key,value,false,true)实现)</div><div class="line">final V putVal(in hash,K key,V vlaue,boolean onlyIfA----------------------------------------------------bsent,boolean evict)    添加新的键值对（将key,value放进一个新的Node节点中，连接入table数组，是HashMap的put，putAll中放入一个mapping时的操作。）</div><div class="line">内部实现步骤主要是：</div><div class="line">1.判断table是否为空或者长度是否为0，若是的话，resize()</div><div class="line">2.判断table尾是否为空，若为空则以hash,key,value,null形成新节点放在尾</div><div class="line">3.若不为空，判断若尾处的结点的key和hash相同则将新的value给予该节点。</div><div class="line">    若该节点时TreeNode类则，以putTreeVal返回一个TreeNode结点</div><div class="line">    否则将结点链接到尾结点的next上形成单向链表(HashMap解决冲突的方法)</div><div class="line">4.加入后若size大于threshold，则resize</div><div class="line"></div><div class="line">final Node&lt;K,V&gt;[] resize();     初始化或者扩大一倍table的size。</div><div class="line">resize是怎么实现的呢</div><div class="line"></div><div class="line">    final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;         </div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;      //判断table数组是否为空，并把当前的length给oldCap</div><div class="line">    int oldThr = threshold;                                 //旧的阈值</div><div class="line">    int newCap, newThr = 0;                                 //定义新的容量和新的阈值</div><div class="line">    if (oldCap &gt; 0) &#123;           </div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;                                             </div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold   </div><div class="line">    &#125;        //判断oldCap是不是超过了最大容量限制，若是的话使全局阈值threshold赋值为Integer.MAX_VALUE，并返回oladTab即旧的table（不再扩容），否则若oldCap扩大一倍仍小于最小容量的话就使新阈值newThr为原来的2倍</div><div class="line"></div><div class="line">    else if (oldThr &gt; 0) // 当oldCap=0且阈值大于0时即初始化，赋值阈值给newCap</div><div class="line">        newCap = oldThr;        </div><div class="line">    else &#123;               // 当阈值为0时指定newCap为默认容量大小，并指定newThr为默认阈值大小。</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThr == 0) &#123;    //当新的阈值为0时（初始化阈值&gt;0的情况下来），设置新的阈值大小为newCap*loadFactor</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;      </div><div class="line">    threshold = newThr;     //令阈值为新的阈值值</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)     </div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;         //创建新的Node数组newTab作为resize后的table</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;  </div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)     //若该bucket只有一个元素就直接放在newTab中对应位置</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;      //e.hash&amp;(newCap-1) 可以找到对应的位置</div><div class="line">                else if (e instanceof TreeNode)             //是否为红黑树结点  JDK1.8开始。。</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); </div><div class="line">                else &#123; // preserve order            //将链表放入对应的位置</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void treeifyBin(Node&lt;K,V&gt; tab,int hash);    将容器的Node节点转换为TreeNode</div><div class="line">void putAll(Map&lt;? extends K,? extends V&gt; m) 将一个map放入本map中（内部用putMapEntries(m,true)）实现</div><div class="line">V remove(Object key);       移除key所对应的entry，内部用removeNode方法实现</div><div class="line">Node&lt;K,V&gt; removeNode(int hash,Object key,Object value,boolean value,boolean movable)    移除参数所对应的结点。</div><div class="line">void clear()    清空map</div><div class="line">boolean containsValue(Object value);    是否包含value(数组遍历+链表遍历)</div><div class="line">Set&lt;K&gt; keySet();    返回一个KeySet(KeySet是HashMap内部的一个final类，继承自AbstractSet,内部实现了set的方法，size,clear,ierator,contains,remove,spliterator,forEach等)</div><div class="line">Collection&lt;V&gt; values(); 返回value的集合 (Values是HashMap内部的一个final类继承自AbstractCollection，实现了基本方法)</div><div class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();     返回entrySet(EntrySet是final类，内部的方法实现主要是对Node数组table进行操作)</div></pre></td></tr></table></figure></p>
<p>接着是一系列JDK8的新方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">V getOrDefault(Object key,V defaulValue);   返回defaultValue为不存在key对应的Node时的默认值。  </div><div class="line">putIfAbsent(K key,V value)  添加新的键值对key-value 且onlyIfAbsent,evict参数均为true</div><div class="line">...余下就不写了</div></pre></td></tr></table></figure></p>
<p>还有一些红黑树的操作以及HashMapIterator的实现就不写了。</p>
<p>总的来说，HashMap作为使用频率最高的的Map，它是通过哈希表的开放地址法和链地址法中的后者解决，此外它不能存储重复的key，但可以重复的value，key和value均为null也可以。扩容是比较耗费时间的，所以最好在创建时指定大概的容量大小，还有，他是线程不安全的，若要多线程操作使用ConcurrentHashMap，此外JDK8加入的很多链转树的操作都是提高了性能，有空会再去细细研究一下。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>WeakHashMap 直接继承自AbstractMap，实现了Map接口。它的特点就是weak keys,在源码注释中也解释者WeakHashMap里的entry不在正常使用时就会被移除，即即使这个key对应的value均存在，也可能被垃圾回收器回收移除。它的用法跟HashMap大体相同，支持key与value均为null，且也不是同步的。而它的Weak机制是通过WeakReference和ReferenceQueue实现的。由于用到的地方比较少，就不多说。<br>这篇文章讲的多一些，可以学习学习。<a href="http://www.cnblogs.com/skywang12345/p/3311092.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3311092.html</a></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable是直接继承自Dictionary的，实现了Map接口，Cloneable接口，Serializable接口，HashTable与HashMap基本是用法相同的，但是HashTable不能存储null作为key或者value，此外HashTable是同步的。因为ConcurrentHashMap的存在，所有即便是多线程操作，也是推荐ConcurrentHashMap而不是HashTable,因为HashTable在任一时间段只能允许一个线程操作，而ConcurrentHashMap引入了分段锁，提高了并发性。所以HashTable的用处也变得很少了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashMap作为使用频率最高的当然要多看。没有说TreeMap的原因时我还没掌握红黑树，等下一篇红黑树和TreeMap以及HashMap在JDK1.8中对红黑树的操作会一起总结学习一下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[3.5 LeetCode 刷题]]></title>
      <url>http://wincber.com/2017/03/06/3-5-LeetCode-%E5%88%B7%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>算法一直不咋地，决定要开始刷一刷算法，每天在LeetCode上做两三道，希望可以做到吧，本着买了就当看了的心态，还买了算法导论。（提前声明，这种算法文章都是我自己刷算法的笔记体会，算法大神不要吐槽，当然欢迎指导）。<br>不扯淡了，今天只做了三道算法题，都是Easy级别的（T_T），不过慢慢积累嘛，就说说这三道。</p>
<h2 id="TwoSum"><a href="#TwoSum" class="headerlink" title="TwoSum"></a>TwoSum</h2><p><a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/two-sum/?tab=Description</a></p>
<p>题目就不说了，这个考的是HashMap的知识（Java中是HashMap，C++的话用Vector），都是利用他们的键值快速查找来解题。<br>这也是巧妙地一点，将值作为Key，索引作为Value，因为Key的查找是快速查找，HashMap中的containsKey(key)中又是利用getNode(hash,key)方法实现，内部实现是利用链表的顺序查找实现。<br>所以我提交的是</p>
<pre><code>public class TwoSum {
public static void main(String[] args){
    TwoSum  ts = new TwoSum();
    int []x = {2,7,11,12,15};
    int []res = ts.twoSum(x,14);
    for(int i = 0;i &lt; res.length;i++){
        System.out.println(i == res.length-1?res[i]:res[i]);
    }
}

/**
 * 考点：Array HashTable
 * HashMap是O(n) Time，O(n) Space,HashMap查找key时是快速查找，所以用索引做value，用值做key进行存储。
 * @param x
 * @param target
 * @return
 */
public int[] twoSum(int []x,int target){
    Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();
    for(int i = 0;i &lt; x.length;i++){
        map.put(x[i],i);
    }
    for(int i = 0;i &lt; x.length;i++){
        int result = target - x[i];
        if(map.containsKey(result) &amp;&amp; i != map.get(result)){
            return new int[]{i+1,map.get(result)+1};
        }
    }
    return null;
}
</code></pre><p>}</p>
<h2 id="HammingDistance"><a href="#HammingDistance" class="headerlink" title="HammingDistance"></a>HammingDistance</h2><p><a href="https://leetcode.com/problems/hamming-distance/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/hamming-distance/?tab=Description</a></p>
<p>这道题很简单，我用的是位运算，将两个二进制数中的1通过异或放在同一个二进制数，在通过移位进行距离的计算。<br>Solution:</p>
<pre><code>public class HammingDistance {
public static void main(String[] args){
    HammingDistance distance = new HammingDistance();
    System.out.println(&quot;Distance: &quot;+ distance.hammingDistance(1,5));
}
public  int hammingDistance(int x, int y){
    int result = x ^ y;
    int dis = 0;
    while(result!= 0){
        if(result % 2 != 0)
            dis++;
        result = result &gt;&gt; 1;
    }
    return dis;
}
</code></pre><p>}</p>
<h2 id="NumberComplement"><a href="#NumberComplement" class="headerlink" title="NumberComplement"></a>NumberComplement</h2><p><a href="https://leetcode.com/problems/number-complement/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/number-complement/?tab=Description</a></p>
<p>这道题也不难，不过我提交失败了好几次，主要是没有考虑周全。要求一个二进制中的0和1互换后的数，刚开始我还考虑了好几种情况，事实证明想多了，我的做法简单来说，因为不以0开头，所以相当于取一位数判断0,1，再进行移位。感觉说的有点不清楚，代码一看就明白</p>
<pre><code>public class NumberComplement {
public static void main(String[] args){
    NumberComplement num = new NumberComplement();
    System.out.println(&quot;Complement is &quot; + num.findComplement(4));
}
public int findComplement(int num){
    int result = 0;
    for(int i = 0; num != 0;i++,num=num&gt;&gt;1){
        result += (num%2==0?1:0)&lt;&lt;i;
    }
    return result;
}
</code></pre><p>}</p>
<p>才第一天，从简单的开始，继续加油！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 开发艺术探索2.4收获（前三小节）]]></title>
      <url>http://wincber.com/2017/03/03/Android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A22-4%E6%94%B6%E8%8E%B7/</url>
      <content type="html"><![CDATA[<p>  2.4讲的是Android中的IPC方式，这一小节比较长（60+页），也是因为Demo代码厂都比较长，所以会分开几篇来讲，这一小节又分几个小节，所以先说个前三个小节。<a id="more"></a></p>
<h2 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h2><p>Bundle是实现了序列化的，平时在写代码中也会用都用来在保存数据然后通过Intent传递的。准确的说它是实现了Parcelable接口。<br>因为比较常用所以讲的比较少。不过值得一提的是一种方案</p>
<pre><code>A进程进行一个计算，计算完后要启动B的一个组件并把计算结果传递给B，但计算结果不支持放入Bundle。
可以A进程通过Intent启用B进程的一个Service进行计算工作，计算完成后在启动B进程所需要的组件，将计算结果给到组件。
</code></pre><h2 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h2><p>Android系统上对文件的并发读写是没有限制的。（但尽量避免并发写），这种方式适合在数据同步要求不高的进程间进行通信。此外特别提出SharedPreferences的特殊性，其底层实现是对xml文件的读写，对于系统对他的读写是有一定的缓存策略，所以并发读写时会有一定的几率丢失数据，高并发时会更严重。所以不建议进程间通信分享SharedPreference。</p>
<p>此外给出了一个Demo，主要是通过一个进程（Activity）开启一个线程，通过序列化将一个对象写入文件，而另一个进程（Activity）开启一个线程，通过反序列化读出文件中的对象。都实现在onResume()中用于数据恢复。<br>代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.ObjectOutputStream;</div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        Intent intent = new Intent(this,SecondActivity.class);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                User user = new User(1,&quot;hello world&quot;,false);</div><div class="line">                ObjectOutputStream outputStream = null;</div><div class="line">                FileOutputStream out = null;</div><div class="line">                try &#123;</div><div class="line">                    out = openFileOutput(&quot;test&quot;, Context.MODE_PRIVATE);</div><div class="line">                    outputStream = new ObjectOutputStream(out);</div><div class="line">                    outputStream.writeObject(user);</div><div class="line">                    Log.d(&quot;MainActivity&quot;,&quot;persist user: write &quot; + user);</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;finally &#123;</div><div class="line">                    try &#123;</div><div class="line">                        outputStream.close();</div><div class="line">                    &#125; catch (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.ObjectInputStream;</div><div class="line"></div><div class="line">public class SecondActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_second);</div><div class="line">        Log.d(&quot;SecondActivity&quot;,&quot;onCreate&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        Log.d(&quot;SecondActivity&quot;,&quot;onResume&quot;);</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                User user = null;</div><div class="line"></div><div class="line">                    ObjectInputStream inputStream = null;</div><div class="line">                    FileInputStream input = null;</div><div class="line">                    try &#123;</div><div class="line">                        input = openFileInput(&quot;test&quot;);</div><div class="line">                        inputStream = new ObjectInputStream(input);</div><div class="line">                        user = (User)inputStream.readObject();</div><div class="line">                        Log.d(&quot;SecondActivity&quot;,&quot;read it&quot; + user);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;finally&#123;</div><div class="line">                        try &#123;</div><div class="line">                            inputStream.close();</div><div class="line">                        &#125; catch (IOException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个小技巧是，因为连个Activity是在两个进程，所以想要单独运行SecondActivity时，需要设置Androidifmainest中的属性，“exported = true”,这样可以单独运行或调试SecondActivity。</p>
<h2 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h2><p>Messenger底层实现是AIDL，适合用来在客户端和服务器端发送请求。这一节也是通过代码demo来讲解Messenger的通信过程，通过构建Service运行在个进程中，通过Messenger发送请求并处理请求，缺点是，服务器端一次只能处理一个客户端发来的请求。<br>记得查看logcat时，删选条件为no filter要不然只能看到你当前进程的log信息。</p>
<p><a href="http://oczm2hjoz.bkt.clouddn.com/image/jpg/MessengerIPC.jpgMessengerIPC.png" target="_blank" rel="external">!测试结果</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面三节的内容都是为第四节AIDL做铺垫，通过Messenger的服务端每次只能处理一个请求而引出AIDL（处理并发请求），AIDL这一节有60+页，会比较费时间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java List小结]]></title>
      <url>http://wincber.com/2017/03/01/java-%E9%9B%86%E5%90%88%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>继续昨天的，集合知识小结。（简单的阅读了源码和网上的一些解读。</p>
<h2 id="Colletion"><a href="#Colletion" class="headerlink" title="Colletion"></a>Colletion</h2><p>和Map并肩构成集合类的最根本的接口，继承自Iterable接口，所有集合都可用迭代器迭代来遍历集合<br><a id="more"></a><br>API主要有：</p>
<pre><code>int size();         集合大小
boolean isEmpty();    是否为空集
boolean contains(Object o);  是否包含o对象
Interator&lt;E&gt; iterator();   返回该集合的迭代器
Object[]  toArray();     集合转数组（无类型）
&lt;T&gt; T[] toArray(T[] a);   集合转数组（建议使用这种方法，且传入数组的类型和大小要和集合一样）
boolean add(E e);   添加元素
boolean remove(Object o)；  删除对象o
boolean containsAll(Collection&lt;?&gt; c);  是否包含另一个集合c
boolean addAll(Collection&lt;? extends E&gt; c);  添加另一个集合
boolean remove All(Collection&lt;?&gt; c); 删除一个集合
default boolean removeIf(predicate&lt;? super E&gt;); filter);  删除满足filter的元素
boolean retainAll(Collection&lt;?&gt; c); 保留集合c的元素，删除其他元素
void clear();  清空集合
</code></pre><h3 id="AbstractCollection-是实现Collection的集合类。实现了Collection除了iterator-和size-抽象方法-以外的其他方法。"><a href="#AbstractCollection-是实现Collection的集合类。实现了Collection除了iterator-和size-抽象方法-以外的其他方法。" class="headerlink" title="AbstractCollection 是实现Collection的集合类。实现了Collection除了iterator()和size()(抽象方法)以外的其他方法。"></a>AbstractCollection 是实现Collection的集合类。实现了Collection除了iterator()和size()(抽象方法)以外的其他方法。</h3><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 继承自 Colletion接口，每个元素都有个索引号，是有序的队列，而且它的元素是可以重复的，除了继承Collection的方法外，还有自己的API接口</p>
<pre><code>boolean add(E e);   添加元素到队尾
boolean remove(Object o)   删除第一次出现的o对象
default void sort(Comparator&lt;? super E&gt; c);    排序（通过Array.sort(c)）  提供比较器用Array.sort来排序
*E get(int index);   获取具体某个索引的元素
*E set(int index,E element)  设置具体某个索引对应的元素为 element
*E add(int index,E element)  在具体索引处插入元素
*E remove(int index) 删除索引为index的元素
*int indexOf(Object o) 查询元素o第一次出现的索引
*int lastIndexOf(Object o) 查询元素o最后一次出现的索引
ListIterator&lt;E&gt; listIterator()  返回有个队列的迭代器
ListIterator&lt;E&gt; listIterator(int index) 返回从index开始的迭代器
*List&lt;E&gt; subList(int fromeIndex,int toIndex) 返回指定的一段子队列
</code></pre><h3 id="AbstractList-继承自AbstractCollection-，实现List接口，除get-和-size-两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类"><a href="#AbstractList-继承自AbstractCollection-，实现List接口，除get-和-size-两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类" class="headerlink" title="AbstractList 继承自AbstractCollection ，实现List接口，除get() 和 size() 两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类"></a>AbstractList 继承自AbstractCollection ，实现List接口，除get() 和 size() 两个抽象方法外实现了List的其他方法，是ArrayList和LinkedList的基类</h3><h4 id="ArrayList-，LinkedList，vector都是继承自AbstractList"><a href="#ArrayList-，LinkedList，vector都是继承自AbstractList" class="headerlink" title="ArrayList ，LinkedList，vector都是继承自AbstractList"></a>ArrayList ，LinkedList，vector都是继承自AbstractList</h4><p>三者区别在于<br>LinkedList：</p>
<pre><code>直接继承的是AbstractSequentialList,且实现了Queue接口。
实际上是一个双向链表，所以它的很多操作都是链表操作，建立链表主要的方法都是私有方法，用于内部链表的建立，比如
定义私有节点类Node&lt;E&gt;
private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
(private)方法
    linkFirst(E e)     链接e作为第一个元素
    unlinkFirst(Node&lt;e&gt; f)  删除非空的第一个节点f
    unlinkLast(Node&lt;e&gt; l)   删除非空的最后一个节点l
    writeObject(java.io.ObjectOutputStream s)  保存链表当前状态到stream中（用于序列化）
    readObject(java.io.ObjectInputStream s)     对应的反序列化
    isElementIndex(int index)   索引index处是否存在元素
    isPositionIndex(int index)  index是否有效
    ...
    （其链表实现与操作的实现与c语言中链表的操作基本相同）

(friendly)方法
    linkLast(E e)   连接e作为队后一个元素
    linkBefore(E e,Node&lt;e&gt; succ)    在节点succ前插入元素e
    unlink(Node&lt;E&gt; x)   删除节点x
其余基本为LinkedList的API,也体现了双向链表的特点（也包含了队列的特点）

    E getFirst()    返回第一个元素
    E getLast()     返回最后一个元素
    E removeFirst() 删除第一个元素
    E removeLast()  删除最后一个元素
    void addFirst(E e)  队头插入元素
    void addLast(E e)   添加元素至队尾
    List所包含的方法都有实现，包括根据索引值来插入删除等。
指的一提的是，LinkedList是没有容量限制的，源码中队size,first(头节点),last(尾节点)都是transient类型的，即暂时性的，他的容量是随操作变化的。此外既然是链表，那么顺序遍历比随机遍历要快，此外他也是线程不安全的，非同步的。
</code></pre><p>ArrayList:</p>
<pre><code>ArrayList是指是一个动态数组，默认容量为10，存储时也是按数组形式存储，当容量不足时，每次增加一半。同样是非同步的。要素是elementData(transient)和size,建议是每次创建时指定好大小。由于是数组形式，遍历时随机访问效率是最高的。
</code></pre><p>Vector</p>
<pre><code>Vector是矢量队列，其特点是可以设置容量的增长指数即capacityIncrement，默认情况下容量不足时是增加一倍。
它的内部实现了许多关于容量的方法以更好的完成对于容量的控制。比如
    ensureCapacityHelper(int minCapacity)   指定最小容量
    grow(int minCapacity)  minCapacity的基础上扩充
    hugeCapacity(int minCapacity)   返回一个大容量
此外，正常情况下分配给array的最大size是Integer.MAX_VALUE - 8 。
注意这里的size和capacity是两个东西，size是元素的数量，capacity是vector的容量。
vector是线程安全的，切随机访问效率最高。
</code></pre><p>Stack</p>
<pre><code>栈是直接继承自Vector的，规律是“后进先出”，也是有特有的的几个方法
push()  压栈
pop()   出栈
peek()  查看栈顶元素
</code></pre><p>##总结<br>做了大概的总结也简单的阅读了源码，其实是有一些关于迭代器的方法没有提到，以后也会再补回来的，明天是Map的相关总结，继续加油！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2月28日：String，StringBuffer，StringBuilder和集合分类]]></title>
      <url>http://wincber.com/2017/02/28/2.28%20java%20List%20%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>2月28日的收获：对String，StringBuffer，StringBuilder进行了小研究，简单地查看了源码，也看了网上的讲解三者的区别和优缺点和使用方法对java中的集合部分有了一定的了解。（通过简单的查看源码以及网上博客分析），还有<a id="more"></a> 给博客站点装了个网易云音乐的外链播放器，还不错哦。还有这两天买了两本书《Android开发艺术探索》，《算法导论》，android要了解深层知识，算法也要刷！</p>
<p>废话：刚开学这两天事特别多，压力也很多，事多是身份证丢了要异地补办麻烦的很，还有报了驾校，接下来的日子也要挤出时间来练车，还好这学期课不是很多（暂时），压力大是因为打算找个实习，刚好最近各大公司都开始了内推，心里很纠结，一方面觉得自己实力不够进大公司（甚至小公司自己心里也没有底），另一方面又想试试，唉，但是不管怎么说接下<br>的日子肯定是要加倍努力。<br>正文：<br>想着要实习，是要看一些面试的题目或者老生常谈的问题，刚好这学期课表里也有java，自己也要巩固一下java。所以就来到了String，StringBuffer，StringBuilder三者，以及集合的分类和使用。</p>
<h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><p>网上分析的文章有很多，但想着自己写一遍更加深了解。。。<br>首先它们都是通过 //char[] 来存储字符串的字符，其中String中的 //char[] 是final型的 所以String是不可变的，而StringBuffer和StringBuilder都是继承自AbstractStringBuilder，其字符串是可变的。<br>所以有常说的String不能修改，而要进行字符串的修改的话使用StringBuffer和StringBuilder，而StringBuffer和StringBuilder的区别在于线程安全区别，看源码可以知道StringBuffer和StringBuilder虽然基类都是AbstractStringBuilder且内部方法实现基本相同，但是区别在于，StringBuffer是线程安全的，其与StringBuilder的方法区别是他的方法都是sychronized的即线程同步的，所以在多线程中使用StringBuffer更加安全，而单线程中的话使用StringBuilder会更加高效。</p>
<h2 id="集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类"><a href="#集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类" class="headerlink" title="集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类"></a>集合：从上至下即从Collection和Map两个接口到两个接口派生的List、Set接口和SortedMap，NegativeMap接口乃至实现各自接口的类</h2><pre><code>List（有序可重复）:ArrayList,LinkedList,Vector,Stack.
Set（不可重复）：HashSet
Map:HashMap HashTable，TreeMap，WeakHashMap
工具类：Arrays，Collections
</code></pre><p>其继承与实现依赖关系可见下图：<br><img src="http://oczm2hjoz.bkt.clouddn.com/Image/jpg/Collection.jpg" width="600" height="500" alt="关系图" align="center"><br>关系很明然对吧，Map这边的还没有看完，所以明天写集合部分的所有总结吧</p>
<p>总结：还是要看一些深层次的东西啊！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2.28 Android IPC前三节收获]]></title>
      <url>http://wincber.com/2017/02/28/2-28-Android-IPC/</url>
      <content type="html"><![CDATA[<p>买了《Android开发艺术探索》，看了IPC这一章节的前两个小节，序列化机制和Binder，即进程间通信这一节，谈谈收获。<br><a id="more"></a><br>进程间通信在Android开发中好像不是很常说（至少以我的目前少得可怜的经验中除了特意测试进程的demo外没有用过进程间通信）。</p>
<h2 id="第一小节-IPC介绍"><a href="#第一小节-IPC介绍" class="headerlink" title="第一小节 IPC介绍"></a>第一小节 IPC介绍</h2><p>第一小节主要介绍了Android IPC机制的概念，主要提出了Andorid上的进程间通信和其他平台上的进程间通信，提到各个平台的特有的进程间通信方式比如Windows的管道，邮槽，Linux上的命名管道，信号量，共享内存等等。<br>而Android上特有的就是Binder，此外还有socket（socket在各个平台都可以吧），而用到进程间通信的场景主要1，应用体积大需要开启多进程来获取多块内,2，特殊模块需要单独运行在单个进程中，3，向其他应用获取数据（用ContentProvider也是进程间通信）。</p>
<h2 id="第二小节-多进程模式"><a href="#第二小节-多进程模式" class="headerlink" title="第二小节 多进程模式"></a>第二小节 多进程模式</h2><p>第一小节通过android:process的设置的demo介绍了开启新进程的方式。<br>第二小节通过创建一个类，通过在不同进程中修改该类中的一个静态变量值而得出的多进程数据不能同步共享因为每个进程中该类是单独的一个副本，修改类中的静态值不会影响其他进程。<br>所以多进程可能造成的问题：</p>
<pre><code>1.静态成员和单例模式完全失效
2.线程同步机制完全失效
3.SharedPreferences的可靠性下降（底层通过读/写 XML文件实现，并发读写会出问题）
4.Application会多次创建（一个进程一个应用）
</code></pre><h2 id="第三小节-序列化机制"><a href="#第三小节-序列化机制" class="headerlink" title="第三小节 序列化机制"></a>第三小节 序列化机制</h2><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>是java的序列化，serialVersionUID就是序列化标记，用于辅助进行序列化和反序列化.通过FileOutputStream，FileInputStream进行读写（这里是读写到文件中）来实现简单的序列化。</p>
<h3 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h3><p>是android特有的序列化实现Serializable接口后，一个类的对象就能实现序列化可以通过Intent和Binder传递。<br>主要实现功能有 </p>
<pre><code>1.序列化  writeToParcel(Parcle out,int flags) 通过Parcel的write方法完成
2.反序列化 CREATOR完成  通过Parcle的read方法完成
3.内容描述 describeContent() 方法完成 （几乎所有情况下都返回0）
</code></pre><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>这节挺难。首先介绍了Binder的概念，是实现了IBinder接口的一个类，是android特有的一个跨进程通信方式。<br>Binder主要用在Service中，包括AIDL和Messenger(底层是AIDL)<br>接着通过生成一个AIDL示例的Demo介绍了系统生成的Binder内部以及如何实现，这一部分比较繁杂，系统生成或者自己写的Binder中重要部分有</p>
<pre><code>1.DESCRIPTOR  Binder的唯一标识（一般是当前类名（包含包名））
2.asInterface(android.os.IBinder obj)   用于将服务端的Binder对象转换成客户端所需的AIDL接口类型对象，可能返回对象本身，可能返回Stub.proxy对象
3.asBinder() 返回当前Binder对象
4.onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags) 运行在Binder线程池中，通过code识别请求方法，data取出数据，reply写入返回值
5.Proxy#getBookList 运行在客户端，通过Parcel对象_data,_reply进行输入输出然后线程挂起，服务端调用ontransact
6.Proxy#addBook 同理
</code></pre><p>暂时到这</p>
<p>总结：IPC机制尤其是Binder虽然我没用过，但是是很有必要了解并明白原理的，明天接着看写！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android服务器端与客户端Socket通信Demo]]></title>
      <url>http://wincber.com/2016/12/04/android%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AFSocket%E9%80%9A%E4%BF%A1Demo/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  最近计网看到TCP/IP协议，和socket通信，看android的网络编程书上刚开始讲TCP/IP协议，并且讲socket通信，就决定接触一下socket编程，这个涉及到服务器端和客户端两个方面，但是原理是一样的。<br><a id="more"></a></p>
<h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a>Socket 通信</h2><p>  至于TCP/IP协议就不详说了，大家也学过，网上也有很多资料，简单的说，TCP是面向连接的，所以这里用到Socket编程使用socket建立服务器与客户端间的连接。</p>
<p>这个小Demo里做了服务器端和客户端，服务器端是在pc，用SocketServer来搭建，客户端在android上，也是用java的socket来建立。</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>  开始时练习的不是在android上，是java上socket通信，简单的一对一的话不用开启线程，要使多个客户端连入的话就需要每次接3受到一个socket连接就开启一个线程来处理这个socket的通信，要想服务器也向客户端发送消息的话就要再开启发送服务器自定义的消息<br>不过我这儿就发送你控制台输入的消息了（System.in）。当然这样就不能单独向某个客户端发送自定义消息了，而且为开启多少个客户端介入的子线程，就开启多少个接受System.in的子线程，所以每个客户端都会接收到同样的自定义消息。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>  客户端方面需要开启两个线程，一个线程是用来与服务器进行通信，一个线程用来更新UI（将服务器发来的消息显示在TextView中）。<br>大概就是这样。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.服务器IP地址问题<br>  这个demo中客户端链接的是局域网中主机的ip，手机要与PC在同一个局域网中，至于如何换成连接公网（不在同一局域网时也可以通信）这个问题比较麻烦，设计点到点通信之类的计算机网络知识，虽说这学期学了计算机网络，但是。。唉不说了<br>反正就是连公网的话还需要您自己去查阅资料解决，我也回去研究研究，不过这里就不解决了<br>2.发送信息紊乱问题<br>（1）多线程的读写：在刚开始时练习时，多个客户端连入，与服务器互发消息会出现乱掉，问题主要出在服务器端，用于读取接入客户端而创建的套接字的socket的BufferedReader以及勇于写入的BufferedWriter都需要定义为局部变量，因为多线程中的socket不同，读取和写入每个都要单独操作，不然就会出现这个线程中读出的显示在另一个线程中发给服务器的InputStream。<br>（2）服务器端接受System.in的消息发送给所有客户端，需要开启同样数量的子线程，否则会出现有些客户端接受不到服务器发送的自定义消息</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>dash<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class ClientThread implements Runnable &#123;</div><div class="line">Handler mHandler;  // 服务器通信 的handler</div><div class="line">public Handler mRevHandler; // 与UI线程通信的handler</div><div class="line">BufferedReader reader;</div><div class="line">BufferedWriter writer;</div><div class="line">Socket mSocket;</div><div class="line">public ClientThread(Handler handler)&#123;</div><div class="line">    mHandler = handler;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    try&#123;</div><div class="line">        mSocket = new Socket();</div><div class="line">        mSocket.connect(new InetSocketAddress(&quot;192.168.191.1&quot;,23333),60000);</div><div class="line">        Log.d(&quot;socket connecting&quot;,&quot;connecting ...&quot;);</div><div class="line">        reader = new BufferedReader(new InputStreamReader(mSocket.getInputStream()));</div><div class="line">        writer = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                String content = null;</div><div class="line">                try &#123;</div><div class="line">                    while((content = reader.readLine() )!= null )&#123;</div><div class="line">                        Message msg = new Message();</div><div class="line">                        Message msg2 = new Message();</div><div class="line">                        msg.what = 0x66;</div><div class="line">                        msg2.what = 0x22;</div><div class="line">                        msg.obj = content ;</div><div class="line">                        msg2.obj = mSocket.hashCode();</div><div class="line">                        mHandler.sendMessage(msg);</div><div class="line">                        mHandler.sendMessage(msg2);</div><div class="line">                        Log.d(&quot;Received message:&quot; ,content);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        Looper.prepare();</div><div class="line">        mRevHandler = new Handler()&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                if(msg.what == 0x11)&#123;</div><div class="line">                    try &#123;</div><div class="line">                        writer.write(msg.obj.toString()+&quot; from &quot;+ mSocket.hashCode()+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125; catch (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Looper.loop();</div><div class="line">    &#125;catch(IOException e)&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;finally &#123;</div><div class="line">        try &#123;</div><div class="line">            reader.close();</div><div class="line">            writer.close();</div><div class="line">            mSocket.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><p>dash<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">    public class MySocketServer &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MySocketServer socketServer = new MySocketServer();</div><div class="line">        socketServer.startServer();</div><div class="line">    &#125;</div><div class="line">    public void startServer() &#123;</div><div class="line">        ServerSocket serverSocket = null;</div><div class="line">        Socket socket = null;</div><div class="line">        try &#123;</div><div class="line">            String ip;</div><div class="line">            InetAddress adr = InetAddress.getLocalHost();</div><div class="line">            ip = adr.getHostAddress();</div><div class="line">            System.out.println(ip);</div><div class="line">            serverSocket = new ServerSocket(23333);</div><div class="line">            System.out.println(&quot;server start&gt;&gt;&quot;);</div><div class="line">            while(true)&#123;</div><div class="line">                socket = serverSocket.accept();</div><div class="line">                setServerInput(socket);</div><div class="line">                manageConnection(socket);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            try &#123;</div><div class="line">                serverSocket.close();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void setServerInput(final Socket socket)&#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            BufferedReader input = null;</div><div class="line">            BufferedWriter writer = null;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    input = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">                    writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">                    String content;</div><div class="line">                    while((content = input.readLine())!= null)&#123;</div><div class="line">                        writer.write(content+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;finally &#123;</div><div class="line">                    try &#123;</div><div class="line">                        input.close();</div><div class="line">                        writer.close();</div><div class="line">                    &#125; catch (IOException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    public void manageConnection(final Socket socket) &#123;</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            BufferedReader reader = null;</div><div class="line">            BufferedWriter writer = null;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;Socket &quot; + socket.hashCode() + &quot; has connected&quot;);</div><div class="line">                    reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</div><div class="line">                    writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">                    String receivedMsg;</div><div class="line">                    while ((receivedMsg = reader.readLine()) != null) &#123;</div><div class="line">                        System.out.println(receivedMsg);</div><div class="line">                        writer.write(&quot;server received : &quot; + receivedMsg+&quot;\n&quot;);</div><div class="line">                        writer.flush();</div><div class="line">                    &#125;</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;finally&#123;</div><div class="line">                    try &#123;</div><div class="line">                        reader.close();</div><div class="line">                        writer.close();</div><div class="line">                    &#125;catch (Exception e )&#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，这是个简单的socket通信，也是最基本的服务器客户端通信方式，从简单的开始，慢慢进步！</p>
<p>gituhb：<a href="https://github.com/wincber/SocketTalkClientDemo" target="_blank" rel="external">https://github.com/wincber/SocketTalkClientDemo</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试题知识点（一）]]></title>
      <url>http://wincber.com/2016/10/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到群里有人发面试题我就试着看了看，发现有很多自己不明白的，所以写这个，一方面相当于自己的笔记，也能更好的记住，理解，另一方面也为其他人提供一些知识点参考吧。<br><a id="more"></a></p>
<h3 id="1-listView-优化问题"><a href="#1-listView-优化问题" class="headerlink" title="1. listView 优化问题"></a>1. listView 优化问题</h3><p>感觉这是个老生常谈的问题了。直接说结果<br>1，使用convertView缓存，即在很多地方看到的写适配器的<em>getView</em>方法中用到的，当converView为null时创建新的布局View，当不为空时直接使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public View getView（int position，View convertView，View parent） &#123;</div><div class="line">    <span class="keyword">if</span>(convertView == null) &#123;</div><div class="line">        //convertView = your layout View</div><div class="line">    &#125;</div><div class="line">    //操作你的控件,convertView作为layout View</div><div class="line">    </div><div class="line">    <span class="built_in">return</span> convertView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2，使用convertView+ViewHolder<br>就像RecycleView中的ViewHolder，将item中的所要操作的控件写到里面，减少了findViewById<br>则改进部分：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ViewHolder mHolder;</div><div class="line"><span class="keyword">if</span>(convertView == null) &#123;</div><div class="line">    convertView = LayoutInflater.from(context).inflate(...);</div><div class="line">    mHolder = new ViewHolder(); </div><div class="line">    mHolder.textView = (TextView)findViewById(R.id.text);</div><div class="line">    mHolder.imageView = (ImageView)findViewById(R.id.image);</div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    mHolder = (ViewHolder)convertView;</div><div class="line">&#125;</div><div class="line">......</div><div class="line"></div><div class="line">还有一些终极优化技巧就不细说了，可以看这个[http://blog.csdn.net/sweetvvck/article/details/12753851]</div></pre></td></tr></table></figure></p>
<h3 id="2，Activity的启动方式有几种，有什么特点？"><a href="#2，Activity的启动方式有几种，有什么特点？" class="headerlink" title="2，Activity的启动方式有几种，有什么特点？"></a>2，Activity的启动方式有几种，有什么特点？</h3><p>这个问题看了Android开发艺术探索的肯定有了解，就直接说<br>·standard 即标准模式，每次要开启同一个activity A时都会新创建一个A的实例<br>·singleTop 即栈顶复用模式 若要创建的activity已在栈顶，则不创建新的实例，只调用onNewIntent，否则创建新的实例<br>·singleTask 即栈内复用模式 ，要创建的栈若在它所需的任务栈中则不创建新的实例但会clearTop，否则创建新的实例，<br>·singleInstance 单实例模式 该activity单独在一个独有的栈内</p>
<p>我看到的都是问singleTask启动方式，A启动B，B启动C,C再启动A，那么只有A在栈顶了。</p>
<h3 id="3，Hanlder-Looper-MessageQueue-Message-他们的关系"><a href="#3，Hanlder-Looper-MessageQueue-Message-他们的关系" class="headerlink" title="3，Hanlder Looper MessageQueue Message 他们的关系"></a>3，Hanlder Looper MessageQueue Message 他们的关系</h3><p>在看第一行代码时就有说这个的章节，主要是讲异步消息处理机制那块，Android的异步消息处理主要就是由这四个部分组成<br>·Message 线程之间传递数据的载体<br>·handler 主要用来发送和处理消息 sendMessage() handleMessage()<br>·MessageQueue  消息队列 存放Handler发送的消息，等待处理，每个线程中只有一个<br>·Looper 线程调用loop函数进入到无限循环，用于取出MessageQueue的消息，传递到handleMessage()，每个线程只有一个</p>
<h3 id="4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？"><a href="#4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？" class="headerlink" title="4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？"></a>4，AsyncTask的原理，使用？与Handler的关系，线程池内管理几个线程？</h3><p>原理还是基于异步消息处理机制<br>AsyncTask是抽象类，需要继承使用，并重写onPreExecute(),doInBackground(params..),onProgressUpdate(progress..),onPostExecute();<br>与Handler关系，AsyncTask实际时Thread+Handler的封装，可以做异步工作同时更新UI，AsyncTask会更加耗费资源<br>api10之前线程池的线程限制5，API10后可自己定制为无限制</p>
<p>先写这四个问题，这里都是直接给出了答案，具体原理以及实现还是最好能去理解记住，有漏错的请提出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android之拍照裁剪]]></title>
      <url>http://wincber.com/2016/10/16/%E6%8B%8D%E7%85%A7%E8%A3%81%E5%89%AA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本现在什么app都是有个人信息这一栏，有你的头像，有你的其他信息什么的，基本上选择头像的逻辑都是点击头像选择1，拍照 2，从图库中选取<br>所以拍照，照片裁剪基本上是必不可少的，也是在把第一行代码实践一遍的时候发现的问题，并尝试了解决。<br><a id="more"></a></p>
<h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><p>要想知道在你开发的时候最合适的姿势还是要去官网看，也是因为书中的代码有些已经被弃用。<br>先是拍照，第一行代码中的拍照intent是 调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">Intent intent = new Intent(“com.android.media.action.IMAGE_CAPTURE”);</div><div class="line">Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE_SECURE);</div></pre></td></tr></table></figure></p>
<p>上述三种调用都可以，需要注意的是<strong>com.android开头的是系统内部应用间的action,在Intent构建中加引号</strong></p>
<p>当然，完整的拍照需要不仅仅是一个intent，还需要用来存储照片的文件，以及用来表示照片的uri。</p>
<p>在这里构建一个方法用来创建你拍照/裁剪后 的图片文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pubilc File createImageFile() throw IOException &#123;</div><div class="line">    String dateFormat = new SimpleDateFormat(<span class="string">"yyyyMMdd_HHmmss"</span>).format(new Date());</div><div class="line">    String imageName = <span class="string">"IMG_"</span> +dateFormat+ <span class="string">"_"</span>;</div><div class="line">    File image = File.createTempFile(</div><div class="line">        imageName,</div><div class="line">        <span class="string">".jpg"</span>,</div><div class="line">        getExternalFileDir(Environment.DIRECTORY_PICTURES);</div><div class="line">    )</div><div class="line">    <span class="built_in">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里设置的存储目录是该应用目录中的Pictures文件夹中</p>
<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>重点在裁剪这里，android是有自带裁剪图片的，但是不同的手机厂商上表现是不同的，所以可以调用系统默认的，但是可能存在一些问题，<br>一些第三方rom会替代默认应用，之前有提过如果你是使用的是com.android.camera.action.IMAGE_CAPTURE的话，<br>因为这个action是系统内部应用间的，所以当第三方应用代替了默认应用，并没有此action，你的应用就会crash，所以可以考虑使用第三方的<br>图片裁剪库。<br>在这里使用的是 <a href="https://github.com/lvillani/android-cropimage" target="_blank" rel="external">https://github.com/lvillani/android-cropimage</a> 这个第三方库，使用方法也很简单，直接看它的Sample就可以<br>需要注意的一点是，因为他提供的知识从图库中选取一张照片来裁剪，当你想在拍照之后直接裁剪拍好的照片的话，<br>就要在你的onActivityResult中添加你的拍照Intent的应答，像这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(requestCode == TAKE_PHOTO &amp;&amp; resultCode == RESULT_OK) &#123;</div><div class="line">    imagUri = data.getData();</div><div class="line">    CropImageIntentBuilder cropIntent = new CropImageIntentBuilder(200,200,imageUri);</div><div class="line">    cropIntent.setSourceImage(imageUri);</div><div class="line">    startActivityForResult(cropIntent.getInten(),CROP_PHOTO);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="展示图片"><a href="#展示图片" class="headerlink" title="展示图片"></a>展示图片</h2><p>这里只用在你的ImageView中展示出来就好了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(requestCode == CROP_PHOTO &amp;&amp; resultCode == RESULT_OK) &#123;</div><div class="line">    try&#123;</div><div class="line">        iv_photo.setImageBitmap(BitmapFactory.decodeStream(getContentResolver.openInputStream(imageUri)));</div><div class="line">    &#125;catch(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>这是系统裁剪和使用这个库裁剪的对比<br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgthird_crop_1.jpg" width="300" height="500" alt="third_crop_1" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgthird_crop_2.jpg" width="300" height="500" alt="third_crop_2" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgsystem_crop_1.jpg" width="300" height="500" alt="system_crop_1" align="center"><br><img src="http://oczm2hjoz.bkt.clouddn.com/image/jpgsystem_crop_2.jpg" width="300" height="500" alt="system_crop_2" align="center"></p>
<p>所以可以看出来要真的比较的话还是系统裁剪好的多（这里测试使用的是魅族手机），可以调节裁剪框的大小，比例<br>而这里用的第三方只能等比例的调节大小，且裁剪框是一个正方形，无法截取全部，当然如果你用来做头像也是当然可以的了<br>另外一点，第三方的ui有点不好看<br>最后一点，第三方裁剪后会按照压缩成代码中的图片尺寸，而系统的话就是裁多大就是多大</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此可见，这个第三方还不够完美，你可以去找找其他好的库，但是如果用来做头像的话这个裁剪是没问题的</p>
<p>遗留问题:在选取照片时，如果我选中了一个照片，几秒钟内不点确定的话，那张图片会取消它的选择状态，并且暂时无法再选中，除非你先选一下另一个，再选它，为什么呢？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView+DialogFragment组合]]></title>
      <url>http://wincber.com/2016/09/17/RecycleView-DialogFragment%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<p>这两天填了坑，总的来说DialogFragment+RecyclerView如果不加动态的数据处理的话只是了解这俩组合还是很简单的，所以我只是用的使DialogFragment+RecycleView再嵌套一个ViewPager。<br>那我先说说大概的结构和步骤。<br><a id="more"></a><br>首先DialogFragment ，想到练DialogFragment是因为android自带的Dialog，AlertDialog等等放在不同版本，风格和样式会不同，用DialogFragment自定义风格好使自己的app风格如一，DialogFragment+RecyclerView可以用到选择账号，选择地区巴拉巴拉，选择什么东西的地方。所以还是在很多地方有用处的</p>
<h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>只说一下在这个练习中的简单使用，若是要看具体详细的使用细节，还是看文档吧<a href="https://developer.android.com/reference/android/app/DialogFragment.html" target="_blank" rel="external">https://developer.android.com/reference/android/app/DialogFragment.html</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyDialogFragment extends DialogFragment &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View  view = inflater.inflate(R.layout.fragment_list,container);</div><div class="line">        RecyclerView mRecyclerView = (RecyclerView)view.findViewById(R.id.list);</div><div class="line">        mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));</div><div class="line">        mRecyclerView.setAdapter(new MyRecyclerAdapter());</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里只是简单的在onCreateView函数中对嵌套的RecyclerView进行了初始化，设置其适配器。所以在这里其用法还是很简单的</p>
<h2 id="DialogFragment中的MyRecyclerAdapter"><a href="#DialogFragment中的MyRecyclerAdapter" class="headerlink" title="DialogFragment中的MyRecyclerAdapter"></a>DialogFragment中的MyRecyclerAdapter</h2><p>记得使用AndroidStudio的话，其实是有自带的RecyclerFragment，但是我为了简便还是另写RecyclerView的处理。处理本身RecyclerView的处理，两个很重要的点是RecyclerView.ViewHolder和RecyclerView.Adapter<holder><br>ViewHolder也就是你的Recycler里的item 详细介绍在这里 <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ViewHolder.html</a><br>而Adapter很熟悉了是你的RecyclerView的适配器。详细介绍在这里 <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html</a><br>我在这个demo里基本没做什么数据处理，所以两者写的很简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class MyRecyclerHolder extends RecyclerView.ViewHolder&#123;</div><div class="line">    ViewPager mViewPager;</div><div class="line"></div><div class="line">    public MyRecyclerHolder(View itemView) &#123;</div><div class="line">        super(itemView);</div><div class="line">        this.mViewPager = (ViewPager)itemView.findViewById(R.id.pager); //在RecyclerView嵌套的ViewPager</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyRecyclerAdapter extends RecyclerView.Adapter&lt;MyRecyclerHolder&gt; &#123;</div><div class="line">    public int currentItem;</div><div class="line">    @Override</div><div class="line">    public MyRecyclerHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        <span class="built_in">return</span> new MyRecyclerHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_list_item,parent,<span class="literal">false</span>));  //载入RecyclerView的item的布局</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(MyRecyclerHolder holder, int position) &#123;</div><div class="line">        currentItem = holder.getPosition();</div><div class="line">        MyViewPagerAdapter mPagerAdapter = new MyViewPagerAdapter(position);  //将当前item的position传给ViewPager</div><div class="line">        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,400);  //对ViewPager的高度进行设置避免出现不显示内容</div><div class="line">        holder.mViewPager.setLayoutParams(params);</div><div class="line">        holder.mViewPager.setAdapter(mPagerAdapter);    //设置ViewPager的适配器</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">getItemCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 4;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></holder></p>
<h2 id="RecyclerView嵌套的ViewPager"><a href="#RecyclerView嵌套的ViewPager" class="headerlink" title="RecyclerView嵌套的ViewPager"></a>RecyclerView嵌套的ViewPager</h2><p>之前有写过ViewPager嵌套ViewPager，所以在这里写的很简单很顺畅，不过在这里没有用FragmentViewPagerAdapter作为ViewPager的适配器，只用的PagerDapter<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MyViewPagerAdapter extends PagerAdapter &#123;</div><div class="line">    int []imagesId = &#123;R.drawable.scenery1,R.drawable.scenery2,R.drawable.scenery3,R.drawable.scenery4,R.drawable.scenery5,R.drawable.scenery6,</div><div class="line">            R.drawable.scenery7,R.drawable.scenery8&#125;;</div><div class="line">    private int mViewPositon;</div><div class="line">    public MyViewPagerAdapter(int position) &#123;</div><div class="line">        mViewPositon = position;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> 2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isViewFromObject(View view, Object object) &#123;</div><div class="line">        <span class="built_in">return</span> view== object;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object instantiateItem(ViewGroup container, int position) &#123;</div><div class="line">       View v =  LayoutInflater.from(container.getContext()).inflate(R.layout.pager_item,container,<span class="literal">false</span>);</div><div class="line">        ImageView mImage = (ImageView)v.findViewById(R.id.pager_image);</div><div class="line">        mImage.setImageDrawable(container.getResources().getDrawable(imagesId[2*mViewPositon+position]));</div><div class="line">        container.addView(v); //将内容添加到container（重要）</div><div class="line">        Log.e(<span class="string">"image"</span>,<span class="string">""</span>+position );</div><div class="line">        <span class="built_in">return</span> v;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void destroyItem(ViewGroup container, int position, Object object) &#123;</div><div class="line">         container.removeView((View) object);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>container.addView(view)</strong>这句代码是很重要的，意味着ViewPager显示的内容。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结来说，其实RecyclerView是一个强大的控件，但是在这里只是进行了小小的展示，并没有用到太多的数据处理，所以想要深究RecyclerView的还是要多看看文档或者其他博客。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager 嵌套 ViewPager（ViewPager不能显示，滑动冲突等问题）]]></title>
      <url>http://wincber.com/2016/09/07/ViewPage-%E5%B5%8C%E5%A5%97-ViewPage/</url>
      <content type="html"><![CDATA[<p>这两天才把ViewPager了解学习了一下，也来填一下这个坑（也熟悉一下markdown语法）<br>就不多介绍概念之类的，之说一说我所遇到的坑和给大家的建议</p>
<h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>ViewPager 感觉就不用再详细介绍了，去网上查的话可以查到一大堆介绍什么的。我也是刚接触，不过确实很多地方都用到，比如微信啊，uc浏览器啊，感觉基本上<a id="more"></a>用Tab的地方基本都会用到viewpager设置一些滑动效果之类的。还有最近看到material design 好好看啊，也是许多demo都用到ViewPager</p>
<p>还是放个官方链接吧，最标准的<br><a href="https://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">官方ViewPager文档</a></p>
<h2 id="ViewPager嵌套"><a href="#ViewPager嵌套" class="headerlink" title="ViewPager嵌套"></a>ViewPager嵌套</h2><p>写ViewPager 主要也是为了更加熟练地用ViewPager，但是光是ViewePager是很简单的，看官方的那个demo就知道了，有一点要说，大家用ViewPager的时候一般都是两种写法，一种就是写普通的PagerAdapter，比如一个简单的PagerAdapter</p>
<h3 id="PagerAdapter"><a href="#PagerAdapter" class="headerlink" title="PagerAdapter"></a>PagerAdapter</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class MyPageAdapter extends PagerAdapter &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> list.size();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public boolean isViewFromObject(View arg0, Object arg1) &#123;</div><div class="line">			<span class="built_in">return</span> arg0 == arg1;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public Object instantiateItem(ViewGroup container, int position) &#123;</div><div class="line">			container.addView(list.get(position));</div><div class="line">			<span class="built_in">return</span> list.get(position);</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void destroyItem(ViewGroup container, int position, Object object) &#123;</div><div class="line">			container.removeView(list.get(position));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这四个方法是你必须要重写的</p>
<p><strong><em>instantiateItem(ViewGroup, int)</em></strong>  是你进行页面操作的函数<br><strong><em>destroyItem(ViewGroup, int, Object)</em></strong>  负责销毁你的页面<br><strong><em>getCount()</em></strong> 你的页面数量<br><strong><em>isViewFromObject(View, Object)</em></strong> 判断当前的页面是否展示<br>具体每个方法或者说这个adapter详细的解析可以看看其他大神的文章<br>比如 <a href="http://blog.csdn.net/dmk877/article/details/50060745" target="_blank" rel="external">http://blog.csdn.net/dmk877/article/details/50060745</a> </p>
<p>而另一种则是官方比较推荐的，适配器用FragmentPagerAdapter来写，官方demo就是用的FragmentPagerAdapter写的，所以我在填坑中用的也是这种</p>
<p>怎么写就不单独说了，可以看我写的，或者看官网或者其他人的。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>其实只要你会用一个ViewPager 后，嵌套一个的话也就是在你的外层ViewPager的页面里加一个ViewPager控件，再在你的外层适配器所用到的Fragment中对这个ViewPager进行适配器设置之类的事件<br>大概就像这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyViewPagerFragment extends Fragment &#123;</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_object,container,<span class="literal">false</span>);</div><div class="line">        ImageView images = (ImageView)view.findViewById(R.id.image_iv);</div><div class="line">        images.setImageDrawable(getResources().getDrawable(getArguments().getInt(<span class="string">"pager"</span>)));</div><div class="line">        NestingViewPager nestPager = (NestingViewPager)view.findViewById(R.id.nesting_vp);</div><div class="line">        nestPager.setAdapter(new NestingViewPagerAdapter(getChildFragmentManager()));</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内层ViewPager的适配器和Fragment再单独写<br>那么遇到的问题有哪些？</p>
<h3 id="内层ViewPager不显示"><a href="#内层ViewPager不显示" class="headerlink" title="内层ViewPager不显示"></a>内层ViewPager不显示</h3><p>因为我的外层ViewPager的布局是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span> </div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span> &gt;</div><div class="line">    &lt;ScrollView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span>&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:id=<span class="string">"@+id/image_iv"</span></div><div class="line">        android:src=<span class="string">"@drawable/icon1"</span></div><div class="line">        android:layout_gravity=<span class="string">"center_horizontal"</span>/&gt;</div><div class="line">    &lt;com.example.wincber.viewpagetest.NestingViewPager</div><div class="line">            android:layout_width=<span class="string">"match_parent"</span></div><div class="line">            android:layout_height=<span class="string">"match_parent"</span></div><div class="line">            android:id=<span class="string">"@+id/nesting_vp"</span>&gt;</div><div class="line">    &lt;/com.example.wincber.viewpagetest.NestingViewPager&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">    &lt;/ScrollView&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>运行后只显示ImageView不显示我的内层ViewPager所以我查阅了很多资料，大概主要有这两点</p>
<h4 id="getChildFragmentManager"><a href="#getChildFragmentManager" class="headerlink" title="getChildFragmentManager()"></a>getChildFragmentManager()</h4><p>内层ViewPager的Adapter（FragmentAdapter）再创建时调用的是<strong><em>getChildFragmentManager()</em></strong><br>当然外层的则调用的是<strong><em>getSupportFragmentManager()</em></strong></p>
<h4 id="ScrollView所嵌套的ViewPager中的Height进行具体的高度设置"><a href="#ScrollView所嵌套的ViewPager中的Height进行具体的高度设置" class="headerlink" title="ScrollView所嵌套的ViewPager中的Height进行具体的高度设置"></a>ScrollView所嵌套的ViewPager中的Height进行具体的高度设置</h4><p>我开始不用ScrollView不能显示完整的View，当然内层的ViewPager也显示不出来，对内层的ViewPager的高度进行设置是最简单直接的方法，缺点就是固定数值的限制<br>当然还有更科学严谨的办法，大家可以看看这篇，作者提供了三种方法<br><a href="http://hellsam.com/2015/01/29/Android%E7%9A%84%E5%9D%91%E4%B9%8BScrollView%E5%B5%8C%E5%A5%97ViewPager/" target="_blank" rel="external">ScrollView里面嵌套ViewPager之后ViewPager中的内容无法显示</a></p>
<p>我遇到的无法显示的问题就是这么解决的啦</p>
<h3 id="滑动问题"><a href="#滑动问题" class="headerlink" title="滑动问题"></a>滑动问题</h3><p>关于滑动问题（内外冲突，内层划置最边上（像第一个页面右划，向最后一个页面左划））我是通过重写<strong><em>onTouchEvent(MotionEvent arg0)</em></strong>来解决（自己写内层ViewPager）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent arg0) &#123;</div><div class="line">      curF.x = arg0.getX();</div><div class="line">      curF.y = arg0.getY();</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(arg0.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">          downF.x = arg0.getX();</div><div class="line">          downF.y = arg0.getY();</div><div class="line">          getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(arg0.getAction() == MotionEvent.ACTION_MOVE) &#123;</div><div class="line">          curF.x =arg0.getX();</div><div class="line">          curF.y=arg0.getY();</div><div class="line">          <span class="keyword">if</span>(Math.abs(curF.x-downF.x) &gt; Math.abs(curF.y - downF.y)) &#123;</div><div class="line">              <span class="keyword">if</span>(curF.x &gt; downF.x) &#123; //右划</div><div class="line">                  <span class="keyword">if</span> (getCurrentItem() == 0) &#123;//第一个页面，需要父控件拦截</div><div class="line">                      getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;//左划</div><div class="line">                  <span class="keyword">if</span> (getCurrentItem() == getAdapter().getCount() - 1) &#123;//最后一个页面，需要拦截</div><div class="line">                      getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;<span class="keyword">else</span> &#123;//上下划，需要拦截</div><div class="line">              getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> super.onTouchEvent(arg0);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>注释也说的很明白了，你肯定能看明白。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ViewPager已经是被用到很多地方的控件了，掌握它还是蛮重要的，通过对其的练习了解到了很多。<br>文章中一些名词或者概念讲的不对或者不清楚的请提出，水平有限，想研究关于ViewPager更深层的问题还是看文档或者大神的文章吧。</p>
<p>这里是我的demo ： <a href="https://github.com/wincber/ViewPager_inside_ViewPager/tree/master" target="_blank" rel="external">https://github.com/wincber/ViewPager_inside_ViewPager/tree/master</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Blog]]></title>
      <url>http://wincber.com/2016/09/02/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to my Blog !今天起开始好好的在这里写一些自己在学习过程中遇到的一些我所认为的重要的东西<br><a id="more"></a></p>
<h2 id="为什么要开博客"><a href="#为什么要开博客" class="headerlink" title="为什么要开博客"></a>为什么要开博客</h2><h3 id="激励自己"><a href="#激励自己" class="headerlink" title="激励自己"></a>激励自己</h3><p>虽然在csdn之类的也写了一些自己学习过程中遇到的问题，但我感觉这个要能更加正式，督促自己能更好的写东西，这里也尽量写一些实用的东西，向那些小问题就尽量避免<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Come on</div></pre></td></tr></table></figure></p>
<h3 id="赶上潮流"><a href="#赶上潮流" class="headerlink" title="赶上潮流"></a>赶上潮流</h3><p>之前就看过很厉害的学长的博客，而最近群里的一些小伙伴也好像都有这方面的意向，我也就赶个热</p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="装逼"><a href="#装逼" class="headerlink" title="装逼"></a>装逼</h3><p>这是我的网站，想想还有点小激动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">It<span class="string">'s my Website</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
